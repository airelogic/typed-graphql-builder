schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""
Direct the client to resolve this field locally, either from the cache or local resolvers.
"""
directive @client(
  """
  When true, the client will never use the cache for this value. See
  https://www.apollographql.com/docs/react/essentials/local-state/#forcing-resolvers-with-clientalways-true
  """
  always: Boolean
) on FIELD | FRAGMENT_DEFINITION | INLINE_FRAGMENT

"""
Export this locally resolved field as a variable to be used in the remainder of this query. See
https://www.apollographql.com/docs/react/essentials/local-state/#using-client-fields-as-variables
"""
directive @export(
  """The variable name to export this field as."""
  as: String!
) on FIELD

"""
Specify a custom store key for this result. See
https://www.apollographql.com/docs/react/advanced/caching/#the-connection-directive
"""
directive @connection(
  """Specify the store key."""
  key: String!

  """
  An array of query argument names to include in the generated custom store key.
  """
  filter: [String!]
) on FIELD

scalar _text

"""
Boolean expression to compare columns of type "_text". All fields are combined with logical 'AND'.
"""
input _text_comparison_exp {
  _eq: _text
  _gt: _text
  _gte: _text
  _in: [_text!]
  _is_null: Boolean
  _lt: _text
  _lte: _text
  _neq: _text
  _nin: [_text!]
}

"""
columns and relationships of "booking"
"""
type booking {
  bookedAt: timestamptz
  bookerName: String
  bookingChannel: booking_channel_enum
  checkIn: timestamptz
  checkOut: timestamptz
  confirmationCode: String

  """An object relationship"""
  connection: connection
  connectionId: uuid
  createdAt: timestamptz
  currency: currency_enum

  """An object relationship"""
  entity: entity
  entityId: uuid
  guestName: String
  guests: Int
  id: uuid!
  isOTA: Boolean

  """An array relationship"""
  lines(
    """distinct select on columns"""
    distinct_on: [line_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [line_order_by!]

    """filter the rows returned"""
    where: line_bool_exp
  ): [line!]!

  """An aggregate relationship"""
  lines_aggregate(
    """distinct select on columns"""
    distinct_on: [line_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [line_order_by!]

    """filter the rows returned"""
    where: line_bool_exp
  ): line_aggregate!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  nights: Int

  """An object relationship"""
  otaBooking: booking
  otaBookingId: uuid

  """An array relationship"""
  relatedBookings(
    """distinct select on columns"""
    distinct_on: [booking_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_order_by!]

    """filter the rows returned"""
    where: booking_bool_exp
  ): [booking!]!

  """An aggregate relationship"""
  relatedBookings_aggregate(
    """distinct select on columns"""
    distinct_on: [booking_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_order_by!]

    """filter the rows returned"""
    where: booking_bool_exp
  ): booking_aggregate!
  status: booking_status_enum

  """An array relationship"""
  tags(
    """distinct select on columns"""
    distinct_on: [tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tag_order_by!]

    """filter the rows returned"""
    where: tag_bool_exp
  ): [tag!]!

  """An aggregate relationship"""
  tags_aggregate(
    """distinct select on columns"""
    distinct_on: [tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tag_order_by!]

    """filter the rows returned"""
    where: tag_bool_exp
  ): tag_aggregate!

  """An object relationship"""
  team: team
  teamId: uuid
  uniqueRef: String

  """An object relationship"""
  unit: unit
  unitId: uuid
  updatedAt: timestamptz
}

"""
aggregated selection of "booking"
"""
type booking_aggregate {
  aggregate: booking_aggregate_fields
  nodes: [booking!]!
}

"""
aggregate fields of "booking"
"""
type booking_aggregate_fields {
  avg: booking_avg_fields
  count(columns: [booking_select_column!], distinct: Boolean): Int!
  max: booking_max_fields
  min: booking_min_fields
  stddev: booking_stddev_fields
  stddev_pop: booking_stddev_pop_fields
  stddev_samp: booking_stddev_samp_fields
  sum: booking_sum_fields
  var_pop: booking_var_pop_fields
  var_samp: booking_var_samp_fields
  variance: booking_variance_fields
}

"""
order by aggregate values of table "booking"
"""
input booking_aggregate_order_by {
  avg: booking_avg_order_by
  count: order_by
  max: booking_max_order_by
  min: booking_min_order_by
  stddev: booking_stddev_order_by
  stddev_pop: booking_stddev_pop_order_by
  stddev_samp: booking_stddev_samp_order_by
  sum: booking_sum_order_by
  var_pop: booking_var_pop_order_by
  var_samp: booking_var_samp_order_by
  variance: booking_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input booking_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "booking"
"""
input booking_arr_rel_insert_input {
  data: [booking_insert_input!]!

  """on conflict condition"""
  on_conflict: booking_on_conflict
}

"""aggregate avg on columns"""
type booking_avg_fields {
  guests: Float
  nights: Float
}

"""
order by avg() on columns of table "booking"
"""
input booking_avg_order_by {
  guests: order_by
  nights: order_by
}

"""
Boolean expression to filter rows from the table "booking". All fields are combined with a logical 'AND'.
"""
input booking_bool_exp {
  _and: [booking_bool_exp!]
  _not: booking_bool_exp
  _or: [booking_bool_exp!]
  bookedAt: timestamptz_comparison_exp
  bookerName: String_comparison_exp
  bookingChannel: booking_channel_enum_comparison_exp
  checkIn: timestamptz_comparison_exp
  checkOut: timestamptz_comparison_exp
  confirmationCode: String_comparison_exp
  connection: connection_bool_exp
  connectionId: uuid_comparison_exp
  createdAt: timestamptz_comparison_exp
  currency: currency_enum_comparison_exp
  entity: entity_bool_exp
  entityId: uuid_comparison_exp
  guestName: String_comparison_exp
  guests: Int_comparison_exp
  id: uuid_comparison_exp
  isOTA: Boolean_comparison_exp
  lines: line_bool_exp
  metadata: jsonb_comparison_exp
  nights: Int_comparison_exp
  otaBooking: booking_bool_exp
  otaBookingId: uuid_comparison_exp
  relatedBookings: booking_bool_exp
  status: booking_status_enum_comparison_exp
  tags: tag_bool_exp
  team: team_bool_exp
  teamId: uuid_comparison_exp
  uniqueRef: String_comparison_exp
  unit: unit_bool_exp
  unitId: uuid_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""
columns and relationships of "booking_channel"
"""
type booking_channel {
  name: String!
}

"""
aggregated selection of "booking_channel"
"""
type booking_channel_aggregate {
  aggregate: booking_channel_aggregate_fields
  nodes: [booking_channel!]!
}

"""
aggregate fields of "booking_channel"
"""
type booking_channel_aggregate_fields {
  count(columns: [booking_channel_select_column!], distinct: Boolean): Int!
  max: booking_channel_max_fields
  min: booking_channel_min_fields
}

"""
Boolean expression to filter rows from the table "booking_channel". All fields are combined with a logical 'AND'.
"""
input booking_channel_bool_exp {
  _and: [booking_channel_bool_exp!]
  _not: booking_channel_bool_exp
  _or: [booking_channel_bool_exp!]
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "booking_channel"
"""
enum booking_channel_constraint {
  """unique or primary key constraint"""
  booking_channel_pkey
}

enum booking_channel_enum {
  airbnb
  bookingcom
  direct
  expedia
  tripadvisor
  vrbo
}

"""
Boolean expression to compare columns of type "booking_channel_enum". All fields are combined with logical 'AND'.
"""
input booking_channel_enum_comparison_exp {
  _eq: booking_channel_enum
  _in: [booking_channel_enum!]
  _is_null: Boolean
  _neq: booking_channel_enum
  _nin: [booking_channel_enum!]
}

"""
input type for inserting data into table "booking_channel"
"""
input booking_channel_insert_input {
  name: String
}

"""aggregate max on columns"""
type booking_channel_max_fields {
  name: String
}

"""aggregate min on columns"""
type booking_channel_min_fields {
  name: String
}

"""
response of any mutation on the table "booking_channel"
"""
type booking_channel_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [booking_channel!]!
}

"""
on conflict condition type for table "booking_channel"
"""
input booking_channel_on_conflict {
  constraint: booking_channel_constraint!
  update_columns: [booking_channel_update_column!]! = []
  where: booking_channel_bool_exp
}

"""Ordering options when selecting data from "booking_channel"."""
input booking_channel_order_by {
  name: order_by
}

"""primary key columns input for table: booking_channel"""
input booking_channel_pk_columns_input {
  name: String!
}

"""
select columns of table "booking_channel"
"""
enum booking_channel_select_column {
  """column name"""
  name
}

"""
input type for updating data in table "booking_channel"
"""
input booking_channel_set_input {
  name: String
}

"""
update columns of table "booking_channel"
"""
enum booking_channel_update_column {
  """column name"""
  name
}

"""
unique or primary key constraints on table "booking"
"""
enum booking_constraint {
  """unique or primary key constraint"""
  booking_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input booking_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input booking_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input booking_delete_key_input {
  metadata: String
}

"""
input type for incrementing numeric columns in table "booking"
"""
input booking_inc_input {
  guests: Int
  nights: Int
}

"""
input type for inserting data into table "booking"
"""
input booking_insert_input {
  bookedAt: timestamptz
  bookerName: String
  bookingChannel: booking_channel_enum
  checkIn: timestamptz
  checkOut: timestamptz
  confirmationCode: String
  connection: connection_obj_rel_insert_input
  connectionId: uuid
  createdAt: timestamptz
  currency: currency_enum
  entity: entity_obj_rel_insert_input
  entityId: uuid
  guestName: String
  guests: Int
  id: uuid
  isOTA: Boolean
  lines: line_arr_rel_insert_input
  metadata: jsonb
  nights: Int
  otaBooking: booking_obj_rel_insert_input
  otaBookingId: uuid
  relatedBookings: booking_arr_rel_insert_input
  status: booking_status_enum
  tags: tag_arr_rel_insert_input
  team: team_obj_rel_insert_input
  teamId: uuid
  uniqueRef: String
  unit: unit_obj_rel_insert_input
  unitId: uuid
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type booking_max_fields {
  bookedAt: timestamptz
  bookerName: String
  checkIn: timestamptz
  checkOut: timestamptz
  confirmationCode: String
  connectionId: uuid
  createdAt: timestamptz
  entityId: uuid
  guestName: String
  guests: Int
  id: uuid
  nights: Int
  otaBookingId: uuid
  teamId: uuid
  uniqueRef: String
  unitId: uuid
  updatedAt: timestamptz
}

"""
order by max() on columns of table "booking"
"""
input booking_max_order_by {
  bookedAt: order_by
  bookerName: order_by
  checkIn: order_by
  checkOut: order_by
  confirmationCode: order_by
  connectionId: order_by
  createdAt: order_by
  entityId: order_by
  guestName: order_by
  guests: order_by
  id: order_by
  nights: order_by
  otaBookingId: order_by
  teamId: order_by
  uniqueRef: order_by
  unitId: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type booking_min_fields {
  bookedAt: timestamptz
  bookerName: String
  checkIn: timestamptz
  checkOut: timestamptz
  confirmationCode: String
  connectionId: uuid
  createdAt: timestamptz
  entityId: uuid
  guestName: String
  guests: Int
  id: uuid
  nights: Int
  otaBookingId: uuid
  teamId: uuid
  uniqueRef: String
  unitId: uuid
  updatedAt: timestamptz
}

"""
order by min() on columns of table "booking"
"""
input booking_min_order_by {
  bookedAt: order_by
  bookerName: order_by
  checkIn: order_by
  checkOut: order_by
  confirmationCode: order_by
  connectionId: order_by
  createdAt: order_by
  entityId: order_by
  guestName: order_by
  guests: order_by
  id: order_by
  nights: order_by
  otaBookingId: order_by
  teamId: order_by
  uniqueRef: order_by
  unitId: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "booking"
"""
type booking_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [booking!]!
}

"""
input type for inserting object relation for remote table "booking"
"""
input booking_obj_rel_insert_input {
  data: booking_insert_input!

  """on conflict condition"""
  on_conflict: booking_on_conflict
}

"""
on conflict condition type for table "booking"
"""
input booking_on_conflict {
  constraint: booking_constraint!
  update_columns: [booking_update_column!]! = []
  where: booking_bool_exp
}

"""Ordering options when selecting data from "booking"."""
input booking_order_by {
  bookedAt: order_by
  bookerName: order_by
  bookingChannel: order_by
  checkIn: order_by
  checkOut: order_by
  confirmationCode: order_by
  connection: connection_order_by
  connectionId: order_by
  createdAt: order_by
  currency: order_by
  entity: entity_order_by
  entityId: order_by
  guestName: order_by
  guests: order_by
  id: order_by
  isOTA: order_by
  lines_aggregate: line_aggregate_order_by
  metadata: order_by
  nights: order_by
  otaBooking: booking_order_by
  otaBookingId: order_by
  relatedBookings_aggregate: booking_aggregate_order_by
  status: order_by
  tags_aggregate: tag_aggregate_order_by
  team: team_order_by
  teamId: order_by
  uniqueRef: order_by
  unit: unit_order_by
  unitId: order_by
  updatedAt: order_by
}

"""primary key columns input for table: booking"""
input booking_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input booking_prepend_input {
  metadata: jsonb
}

"""
select columns of table "booking"
"""
enum booking_select_column {
  """column name"""
  bookedAt

  """column name"""
  bookerName

  """column name"""
  bookingChannel

  """column name"""
  checkIn

  """column name"""
  checkOut

  """column name"""
  confirmationCode

  """column name"""
  connectionId

  """column name"""
  createdAt

  """column name"""
  currency

  """column name"""
  entityId

  """column name"""
  guestName

  """column name"""
  guests

  """column name"""
  id

  """column name"""
  isOTA

  """column name"""
  metadata

  """column name"""
  nights

  """column name"""
  otaBookingId

  """column name"""
  status

  """column name"""
  teamId

  """column name"""
  uniqueRef

  """column name"""
  unitId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "booking"
"""
input booking_set_input {
  bookedAt: timestamptz
  bookerName: String
  bookingChannel: booking_channel_enum
  checkIn: timestamptz
  checkOut: timestamptz
  confirmationCode: String
  connectionId: uuid
  createdAt: timestamptz
  currency: currency_enum
  entityId: uuid
  guestName: String
  guests: Int
  id: uuid
  isOTA: Boolean
  metadata: jsonb
  nights: Int
  otaBookingId: uuid
  status: booking_status_enum
  teamId: uuid
  uniqueRef: String
  unitId: uuid
  updatedAt: timestamptz
}

enum booking_status_enum {
  booked
  cancelled
  inquired
  inquiry
  payed
}

"""
Boolean expression to compare columns of type "booking_status_enum". All fields are combined with logical 'AND'.
"""
input booking_status_enum_comparison_exp {
  _eq: booking_status_enum
  _in: [booking_status_enum!]
  _is_null: Boolean
  _neq: booking_status_enum
  _nin: [booking_status_enum!]
}

"""aggregate stddev on columns"""
type booking_stddev_fields {
  guests: Float
  nights: Float
}

"""
order by stddev() on columns of table "booking"
"""
input booking_stddev_order_by {
  guests: order_by
  nights: order_by
}

"""aggregate stddev_pop on columns"""
type booking_stddev_pop_fields {
  guests: Float
  nights: Float
}

"""
order by stddev_pop() on columns of table "booking"
"""
input booking_stddev_pop_order_by {
  guests: order_by
  nights: order_by
}

"""aggregate stddev_samp on columns"""
type booking_stddev_samp_fields {
  guests: Float
  nights: Float
}

"""
order by stddev_samp() on columns of table "booking"
"""
input booking_stddev_samp_order_by {
  guests: order_by
  nights: order_by
}

"""aggregate sum on columns"""
type booking_sum_fields {
  guests: Int
  nights: Int
}

"""
order by sum() on columns of table "booking"
"""
input booking_sum_order_by {
  guests: order_by
  nights: order_by
}

"""
update columns of table "booking"
"""
enum booking_update_column {
  """column name"""
  bookedAt

  """column name"""
  bookerName

  """column name"""
  bookingChannel

  """column name"""
  checkIn

  """column name"""
  checkOut

  """column name"""
  confirmationCode

  """column name"""
  connectionId

  """column name"""
  createdAt

  """column name"""
  currency

  """column name"""
  entityId

  """column name"""
  guestName

  """column name"""
  guests

  """column name"""
  id

  """column name"""
  isOTA

  """column name"""
  metadata

  """column name"""
  nights

  """column name"""
  otaBookingId

  """column name"""
  status

  """column name"""
  teamId

  """column name"""
  uniqueRef

  """column name"""
  unitId

  """column name"""
  updatedAt
}

"""aggregate var_pop on columns"""
type booking_var_pop_fields {
  guests: Float
  nights: Float
}

"""
order by var_pop() on columns of table "booking"
"""
input booking_var_pop_order_by {
  guests: order_by
  nights: order_by
}

"""aggregate var_samp on columns"""
type booking_var_samp_fields {
  guests: Float
  nights: Float
}

"""
order by var_samp() on columns of table "booking"
"""
input booking_var_samp_order_by {
  guests: order_by
  nights: order_by
}

"""aggregate variance on columns"""
type booking_variance_fields {
  guests: Float
  nights: Float
}

"""
order by variance() on columns of table "booking"
"""
input booking_variance_order_by {
  guests: order_by
  nights: order_by
}

"""
columns and relationships of "booking_status"
"""
type bookingStatus {
  name: String!
}

"""
aggregated selection of "booking_status"
"""
type bookingStatus_aggregate {
  aggregate: bookingStatus_aggregate_fields
  nodes: [bookingStatus!]!
}

"""
aggregate fields of "booking_status"
"""
type bookingStatus_aggregate_fields {
  count(columns: [bookingStatus_select_column!], distinct: Boolean): Int!
  max: bookingStatus_max_fields
  min: bookingStatus_min_fields
}

"""
Boolean expression to filter rows from the table "booking_status". All fields are combined with a logical 'AND'.
"""
input bookingStatus_bool_exp {
  _and: [bookingStatus_bool_exp!]
  _not: bookingStatus_bool_exp
  _or: [bookingStatus_bool_exp!]
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "booking_status"
"""
enum bookingStatus_constraint {
  """unique or primary key constraint"""
  booking_status_pkey
}

"""
input type for inserting data into table "booking_status"
"""
input bookingStatus_insert_input {
  name: String
}

"""aggregate max on columns"""
type bookingStatus_max_fields {
  name: String
}

"""aggregate min on columns"""
type bookingStatus_min_fields {
  name: String
}

"""
response of any mutation on the table "booking_status"
"""
type bookingStatus_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [bookingStatus!]!
}

"""
on conflict condition type for table "booking_status"
"""
input bookingStatus_on_conflict {
  constraint: bookingStatus_constraint!
  update_columns: [bookingStatus_update_column!]! = []
  where: bookingStatus_bool_exp
}

"""Ordering options when selecting data from "booking_status"."""
input bookingStatus_order_by {
  name: order_by
}

"""primary key columns input for table: bookingStatus"""
input bookingStatus_pk_columns_input {
  name: String!
}

"""
select columns of table "booking_status"
"""
enum bookingStatus_select_column {
  """column name"""
  name
}

"""
input type for updating data in table "booking_status"
"""
input bookingStatus_set_input {
  name: String
}

"""
update columns of table "booking_status"
"""
enum bookingStatus_update_column {
  """column name"""
  name
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
columns and relationships of "classification"
"""
type classification {
  name: String!
}

"""
aggregated selection of "classification"
"""
type classification_aggregate {
  aggregate: classification_aggregate_fields
  nodes: [classification!]!
}

"""
aggregate fields of "classification"
"""
type classification_aggregate_fields {
  count(columns: [classification_select_column!], distinct: Boolean): Int!
  max: classification_max_fields
  min: classification_min_fields
}

"""
Boolean expression to filter rows from the table "classification". All fields are combined with a logical 'AND'.
"""
input classification_bool_exp {
  _and: [classification_bool_exp!]
  _not: classification_bool_exp
  _or: [classification_bool_exp!]
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "classification"
"""
enum classification_constraint {
  """unique or primary key constraint"""
  classification_pkey
}

enum classification_enum {
  adjustment
  commission
  exception
  paymentFee
  revenue
  securityDeposit
  tax
}

"""
Boolean expression to compare columns of type "classification_enum". All fields are combined with logical 'AND'.
"""
input classification_enum_comparison_exp {
  _eq: classification_enum
  _in: [classification_enum!]
  _is_null: Boolean
  _neq: classification_enum
  _nin: [classification_enum!]
}

"""
input type for inserting data into table "classification"
"""
input classification_insert_input {
  name: String
}

"""aggregate max on columns"""
type classification_max_fields {
  name: String
}

"""aggregate min on columns"""
type classification_min_fields {
  name: String
}

"""
response of any mutation on the table "classification"
"""
type classification_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [classification!]!
}

"""
on conflict condition type for table "classification"
"""
input classification_on_conflict {
  constraint: classification_constraint!
  update_columns: [classification_update_column!]! = []
  where: classification_bool_exp
}

"""Ordering options when selecting data from "classification"."""
input classification_order_by {
  name: order_by
}

"""primary key columns input for table: classification"""
input classification_pk_columns_input {
  name: String!
}

"""
select columns of table "classification"
"""
enum classification_select_column {
  """column name"""
  name
}

"""
input type for updating data in table "classification"
"""
input classification_set_input {
  name: String
}

"""
update columns of table "classification"
"""
enum classification_update_column {
  """column name"""
  name
}

"""
columns and relationships of "connection"
"""
type connection {
  """An array relationship"""
  bookings(
    """distinct select on columns"""
    distinct_on: [booking_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_order_by!]

    """filter the rows returned"""
    where: booking_bool_exp
  ): [booking!]!

  """An aggregate relationship"""
  bookings_aggregate(
    """distinct select on columns"""
    distinct_on: [booking_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_order_by!]

    """filter the rows returned"""
    where: booking_bool_exp
  ): booking_aggregate!
  createdAt: timestamptz!
  credentials(
    """JSON select path"""
    path: String
  ): jsonb

  """An array relationship"""
  entities(
    """distinct select on columns"""
    distinct_on: [entity_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [entity_order_by!]

    """filter the rows returned"""
    where: entity_bool_exp
  ): [entity!]!

  """An aggregate relationship"""
  entities_aggregate(
    """distinct select on columns"""
    distinct_on: [entity_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [entity_order_by!]

    """filter the rows returned"""
    where: entity_bool_exp
  ): entity_aggregate!
  id: uuid!

  """An object relationship"""
  integration: integration!
  integrationId: uuid!

  """An array relationship"""
  jobs(
    """distinct select on columns"""
    distinct_on: [job_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [job_order_by!]

    """filter the rows returned"""
    where: job_bool_exp
  ): [job!]!

  """An aggregate relationship"""
  jobs_aggregate(
    """distinct select on columns"""
    distinct_on: [job_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [job_order_by!]

    """filter the rows returned"""
    where: job_bool_exp
  ): job_aggregate!

  """An array relationship"""
  lines(
    """distinct select on columns"""
    distinct_on: [line_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [line_order_by!]

    """filter the rows returned"""
    where: line_bool_exp
  ): [line!]!

  """An aggregate relationship"""
  lines_aggregate(
    """distinct select on columns"""
    distinct_on: [line_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [line_order_by!]

    """filter the rows returned"""
    where: line_bool_exp
  ): line_aggregate!

  """An array relationship"""
  metrics(
    """distinct select on columns"""
    distinct_on: [metric_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [metric_order_by!]

    """filter the rows returned"""
    where: metric_bool_exp
  ): [metric!]!

  """An aggregate relationship"""
  metrics_aggregate(
    """distinct select on columns"""
    distinct_on: [metric_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [metric_order_by!]

    """filter the rows returned"""
    where: metric_bool_exp
  ): metric_aggregate!
  name: String!

  """An array relationship"""
  payments(
    """distinct select on columns"""
    distinct_on: [payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_order_by!]

    """filter the rows returned"""
    where: payment_bool_exp
  ): [payment!]!

  """An aggregate relationship"""
  payments_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_order_by!]

    """filter the rows returned"""
    where: payment_bool_exp
  ): payment_aggregate!
  persistentState(
    """JSON select path"""
    path: String
  ): jsonb
  status: String

  """An array relationship"""
  tags(
    """distinct select on columns"""
    distinct_on: [tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tag_order_by!]

    """filter the rows returned"""
    where: tag_bool_exp
  ): [tag!]!

  """An aggregate relationship"""
  tags_aggregate(
    """distinct select on columns"""
    distinct_on: [tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tag_order_by!]

    """filter the rows returned"""
    where: tag_bool_exp
  ): tag_aggregate!

  """An object relationship"""
  team: team!
  teamId: uuid!

  """An array relationship"""
  units(
    """distinct select on columns"""
    distinct_on: [unit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [unit_order_by!]

    """filter the rows returned"""
    where: unit_bool_exp
  ): [unit!]!

  """An aggregate relationship"""
  units_aggregate(
    """distinct select on columns"""
    distinct_on: [unit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [unit_order_by!]

    """filter the rows returned"""
    where: unit_bool_exp
  ): unit_aggregate!
  webhookKey: String
}

"""
aggregated selection of "connection"
"""
type connection_aggregate {
  aggregate: connection_aggregate_fields
  nodes: [connection!]!
}

"""
aggregate fields of "connection"
"""
type connection_aggregate_fields {
  count(columns: [connection_select_column!], distinct: Boolean): Int!
  max: connection_max_fields
  min: connection_min_fields
}

"""
order by aggregate values of table "connection"
"""
input connection_aggregate_order_by {
  count: order_by
  max: connection_max_order_by
  min: connection_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input connection_append_input {
  credentials: jsonb
  persistentState: jsonb
}

"""
input type for inserting array relation for remote table "connection"
"""
input connection_arr_rel_insert_input {
  data: [connection_insert_input!]!

  """on conflict condition"""
  on_conflict: connection_on_conflict
}

"""
Boolean expression to filter rows from the table "connection". All fields are combined with a logical 'AND'.
"""
input connection_bool_exp {
  _and: [connection_bool_exp!]
  _not: connection_bool_exp
  _or: [connection_bool_exp!]
  bookings: booking_bool_exp
  createdAt: timestamptz_comparison_exp
  credentials: jsonb_comparison_exp
  entities: entity_bool_exp
  id: uuid_comparison_exp
  integration: integration_bool_exp
  integrationId: uuid_comparison_exp
  jobs: job_bool_exp
  lines: line_bool_exp
  metrics: metric_bool_exp
  name: String_comparison_exp
  payments: payment_bool_exp
  persistentState: jsonb_comparison_exp
  status: String_comparison_exp
  tags: tag_bool_exp
  team: team_bool_exp
  teamId: uuid_comparison_exp
  units: unit_bool_exp
  webhookKey: String_comparison_exp
}

"""
unique or primary key constraints on table "connection"
"""
enum connection_constraint {
  """unique or primary key constraint"""
  connection_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input connection_delete_at_path_input {
  credentials: [String!]
  persistentState: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input connection_delete_elem_input {
  credentials: Int
  persistentState: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input connection_delete_key_input {
  credentials: String
  persistentState: String
}

"""
input type for inserting data into table "connection"
"""
input connection_insert_input {
  bookings: booking_arr_rel_insert_input
  createdAt: timestamptz
  credentials: jsonb
  entities: entity_arr_rel_insert_input
  id: uuid
  integration: integration_obj_rel_insert_input
  integrationId: uuid
  jobs: job_arr_rel_insert_input
  lines: line_arr_rel_insert_input
  metrics: metric_arr_rel_insert_input
  name: String
  payments: payment_arr_rel_insert_input
  persistentState: jsonb
  status: String
  tags: tag_arr_rel_insert_input
  team: team_obj_rel_insert_input
  teamId: uuid
  units: unit_arr_rel_insert_input
  webhookKey: String
}

"""aggregate max on columns"""
type connection_max_fields {
  createdAt: timestamptz
  id: uuid
  integrationId: uuid
  name: String
  status: String
  teamId: uuid
  webhookKey: String
}

"""
order by max() on columns of table "connection"
"""
input connection_max_order_by {
  createdAt: order_by
  id: order_by
  integrationId: order_by
  name: order_by
  status: order_by
  teamId: order_by
  webhookKey: order_by
}

"""aggregate min on columns"""
type connection_min_fields {
  createdAt: timestamptz
  id: uuid
  integrationId: uuid
  name: String
  status: String
  teamId: uuid
  webhookKey: String
}

"""
order by min() on columns of table "connection"
"""
input connection_min_order_by {
  createdAt: order_by
  id: order_by
  integrationId: order_by
  name: order_by
  status: order_by
  teamId: order_by
  webhookKey: order_by
}

"""
response of any mutation on the table "connection"
"""
type connection_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [connection!]!
}

"""
input type for inserting object relation for remote table "connection"
"""
input connection_obj_rel_insert_input {
  data: connection_insert_input!

  """on conflict condition"""
  on_conflict: connection_on_conflict
}

"""
on conflict condition type for table "connection"
"""
input connection_on_conflict {
  constraint: connection_constraint!
  update_columns: [connection_update_column!]! = []
  where: connection_bool_exp
}

"""Ordering options when selecting data from "connection"."""
input connection_order_by {
  bookings_aggregate: booking_aggregate_order_by
  createdAt: order_by
  credentials: order_by
  entities_aggregate: entity_aggregate_order_by
  id: order_by
  integration: integration_order_by
  integrationId: order_by
  jobs_aggregate: job_aggregate_order_by
  lines_aggregate: line_aggregate_order_by
  metrics_aggregate: metric_aggregate_order_by
  name: order_by
  payments_aggregate: payment_aggregate_order_by
  persistentState: order_by
  status: order_by
  tags_aggregate: tag_aggregate_order_by
  team: team_order_by
  teamId: order_by
  units_aggregate: unit_aggregate_order_by
  webhookKey: order_by
}

"""primary key columns input for table: connection"""
input connection_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input connection_prepend_input {
  credentials: jsonb
  persistentState: jsonb
}

"""
select columns of table "connection"
"""
enum connection_select_column {
  """column name"""
  createdAt

  """column name"""
  credentials

  """column name"""
  id

  """column name"""
  integrationId

  """column name"""
  name

  """column name"""
  persistentState

  """column name"""
  status

  """column name"""
  teamId

  """column name"""
  webhookKey
}

"""
input type for updating data in table "connection"
"""
input connection_set_input {
  createdAt: timestamptz
  credentials: jsonb
  id: uuid
  integrationId: uuid
  name: String
  persistentState: jsonb
  status: String
  teamId: uuid
  webhookKey: String
}

"""
update columns of table "connection"
"""
enum connection_update_column {
  """column name"""
  createdAt

  """column name"""
  credentials

  """column name"""
  id

  """column name"""
  integrationId

  """column name"""
  name

  """column name"""
  persistentState

  """column name"""
  status

  """column name"""
  teamId

  """column name"""
  webhookKey
}

"""
columns and relationships of "currency"
"""
type currency {
  name: String!
}

"""
aggregated selection of "currency"
"""
type currency_aggregate {
  aggregate: currency_aggregate_fields
  nodes: [currency!]!
}

"""
aggregate fields of "currency"
"""
type currency_aggregate_fields {
  count(columns: [currency_select_column!], distinct: Boolean): Int!
  max: currency_max_fields
  min: currency_min_fields
}

"""
Boolean expression to filter rows from the table "currency". All fields are combined with a logical 'AND'.
"""
input currency_bool_exp {
  _and: [currency_bool_exp!]
  _not: currency_bool_exp
  _or: [currency_bool_exp!]
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "currency"
"""
enum currency_constraint {
  """unique or primary key constraint"""
  currency_pkey
}

enum currency_enum {
  aed
  afn
  all
  amd
  ang
  aoa
  ars
  aud
  awg
  azn
  bam
  bbd
  bdt
  bgn
  bhd
  bif
  bmd
  bnd
  bob
  bov
  brl
  bsd
  btn
  bwp
  byr
  bzd
  cad
  cdf
  che
  chf
  chw
  clf
  clp
  cny
  cop
  cou
  crc
  cuc
  cup
  cve
  czk
  djf
  dkk
  dop
  dzd
  egp
  ern
  etb
  eur
  fjd
  fkp
  gbp
  gel
  ghs
  gip
  gmd
  gnf
  gtq
  gyd
  hkd
  hnl
  hrk
  htg
  huf
  idr
  ils
  inr
  iqd
  irr
  isk
  jmd
  jod
  jpy
  kes
  kgs
  khr
  kmf
  kpw
  krw
  kwd
  kyd
  kzt
  lak
  lbp
  lkr
  lrd
  lsl
  ltl
  lvl
  lyd
  mad
  mdl
  mga
  mkd
  mmk
  mnt
  mop
  mro
  mur
  mvr
  mwk
  mxn
  mxv
  myr
  mzn
  nad
  ngn
  nio
  nok
  npr
  nzd
  omr
  pab
  pen
  pgk
  php
  pkr
  pln
  pyg
  qar
  ron
  rsd
  rub
  rwf
  sar
  sbd
  scr
  sdg
  sek
  sgd
  shp
  sll
  sos
  srd
  ssp
  std
  syp
  szl
  thb
  tjs
  tmt
  tnd
  top
  try
  ttd
  twd
  tzs
  uah
  ugx
  usd
  usn
  uss
  uyi
  uyu
  uzs
  vef
  vnd
  vuv
  wst
  xaf
  xag
  xau
  xba
  xbb
  xbc
  xbd
  xcd
  xdr
  xfu
  xof
  xpd
  xpf
  xpt
  xts
  xxx
  yer
  zar
  zmw
}

"""
Boolean expression to compare columns of type "currency_enum". All fields are combined with logical 'AND'.
"""
input currency_enum_comparison_exp {
  _eq: currency_enum
  _in: [currency_enum!]
  _is_null: Boolean
  _neq: currency_enum
  _nin: [currency_enum!]
}

"""
input type for inserting data into table "currency"
"""
input currency_insert_input {
  name: String
}

"""aggregate max on columns"""
type currency_max_fields {
  name: String
}

"""aggregate min on columns"""
type currency_min_fields {
  name: String
}

"""
response of any mutation on the table "currency"
"""
type currency_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [currency!]!
}

"""
on conflict condition type for table "currency"
"""
input currency_on_conflict {
  constraint: currency_constraint!
  update_columns: [currency_update_column!]! = []
  where: currency_bool_exp
}

"""Ordering options when selecting data from "currency"."""
input currency_order_by {
  name: order_by
}

"""primary key columns input for table: currency"""
input currency_pk_columns_input {
  name: String!
}

"""
select columns of table "currency"
"""
enum currency_select_column {
  """column name"""
  name
}

"""
input type for updating data in table "currency"
"""
input currency_set_input {
  name: String
}

"""
update columns of table "currency"
"""
enum currency_update_column {
  """column name"""
  name
}

"""
columns and relationships of "entity"
"""
type entity {
  """An array relationship"""
  bookings(
    """distinct select on columns"""
    distinct_on: [booking_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_order_by!]

    """filter the rows returned"""
    where: booking_bool_exp
  ): [booking!]!

  """An aggregate relationship"""
  bookings_aggregate(
    """distinct select on columns"""
    distinct_on: [booking_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_order_by!]

    """filter the rows returned"""
    where: booking_bool_exp
  ): booking_aggregate!

  """An object relationship"""
  connection: connection!
  connectionId: uuid!
  createdAt: timestamptz!
  description: String!
  diffJson(
    """JSON select path"""
    path: String
  ): jsonb
  hash: String
  id: uuid!

  """An object relationship"""
  job: job
  jobId: uuid
  json(
    """JSON select path"""
    path: String
  ): jsonb
  normalizedJson(
    """JSON select path"""
    path: String
  ): jsonb
  normalizedType: normalized_type_enum
  parsedAt: timestamptz

  """An array relationship"""
  payments(
    """distinct select on columns"""
    distinct_on: [payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_order_by!]

    """filter the rows returned"""
    where: payment_bool_exp
  ): [payment!]!

  """An aggregate relationship"""
  payments_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_order_by!]

    """filter the rows returned"""
    where: payment_bool_exp
  ): payment_aggregate!

  """An object relationship"""
  predecessorEntity: entity
  predecessorEntityId: uuid
  status: entity_status_enum!
  statusText: String

  """An array relationship"""
  successorEntities(
    """distinct select on columns"""
    distinct_on: [entity_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [entity_order_by!]

    """filter the rows returned"""
    where: entity_bool_exp
  ): [entity!]!

  """An aggregate relationship"""
  successorEntities_aggregate(
    """distinct select on columns"""
    distinct_on: [entity_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [entity_order_by!]

    """filter the rows returned"""
    where: entity_bool_exp
  ): entity_aggregate!

  """An object relationship"""
  team: team
  teamId: uuid
  type: String!
  uniqueRef: String

  """An array relationship"""
  units(
    """distinct select on columns"""
    distinct_on: [unit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [unit_order_by!]

    """filter the rows returned"""
    where: unit_bool_exp
  ): [unit!]!

  """An aggregate relationship"""
  units_aggregate(
    """distinct select on columns"""
    distinct_on: [unit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [unit_order_by!]

    """filter the rows returned"""
    where: unit_bool_exp
  ): unit_aggregate!
  updatedAt: timestamptz!
}

"""
aggregated selection of "entity"
"""
type entity_aggregate {
  aggregate: entity_aggregate_fields
  nodes: [entity!]!
}

"""
aggregate fields of "entity"
"""
type entity_aggregate_fields {
  count(columns: [entity_select_column!], distinct: Boolean): Int!
  max: entity_max_fields
  min: entity_min_fields
}

"""
order by aggregate values of table "entity"
"""
input entity_aggregate_order_by {
  count: order_by
  max: entity_max_order_by
  min: entity_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input entity_append_input {
  diffJson: jsonb
  json: jsonb
  normalizedJson: jsonb
}

"""
input type for inserting array relation for remote table "entity"
"""
input entity_arr_rel_insert_input {
  data: [entity_insert_input!]!

  """on conflict condition"""
  on_conflict: entity_on_conflict
}

"""
Boolean expression to filter rows from the table "entity". All fields are combined with a logical 'AND'.
"""
input entity_bool_exp {
  _and: [entity_bool_exp!]
  _not: entity_bool_exp
  _or: [entity_bool_exp!]
  bookings: booking_bool_exp
  connection: connection_bool_exp
  connectionId: uuid_comparison_exp
  createdAt: timestamptz_comparison_exp
  description: String_comparison_exp
  diffJson: jsonb_comparison_exp
  hash: String_comparison_exp
  id: uuid_comparison_exp
  job: job_bool_exp
  jobId: uuid_comparison_exp
  json: jsonb_comparison_exp
  normalizedJson: jsonb_comparison_exp
  normalizedType: normalized_type_enum_comparison_exp
  parsedAt: timestamptz_comparison_exp
  payments: payment_bool_exp
  predecessorEntity: entity_bool_exp
  predecessorEntityId: uuid_comparison_exp
  status: entity_status_enum_comparison_exp
  statusText: String_comparison_exp
  successorEntities: entity_bool_exp
  team: team_bool_exp
  teamId: uuid_comparison_exp
  type: String_comparison_exp
  uniqueRef: String_comparison_exp
  units: unit_bool_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "entity"
"""
enum entity_constraint {
  """unique or primary key constraint"""
  entity_connection_id_job_id_type_unique_ref_key

  """unique or primary key constraint"""
  entity_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input entity_delete_at_path_input {
  diffJson: [String!]
  json: [String!]
  normalizedJson: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input entity_delete_elem_input {
  diffJson: Int
  json: Int
  normalizedJson: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input entity_delete_key_input {
  diffJson: String
  json: String
  normalizedJson: String
}

"""
input type for inserting data into table "entity"
"""
input entity_insert_input {
  bookings: booking_arr_rel_insert_input
  connection: connection_obj_rel_insert_input
  connectionId: uuid
  createdAt: timestamptz
  description: String
  diffJson: jsonb
  hash: String
  id: uuid
  job: job_obj_rel_insert_input
  jobId: uuid
  json: jsonb
  normalizedJson: jsonb
  normalizedType: normalized_type_enum
  parsedAt: timestamptz
  payments: payment_arr_rel_insert_input
  predecessorEntity: entity_obj_rel_insert_input
  predecessorEntityId: uuid
  status: entity_status_enum
  statusText: String
  successorEntities: entity_arr_rel_insert_input
  team: team_obj_rel_insert_input
  teamId: uuid
  type: String
  uniqueRef: String
  units: unit_arr_rel_insert_input
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type entity_max_fields {
  connectionId: uuid
  createdAt: timestamptz
  description: String
  hash: String
  id: uuid
  jobId: uuid
  parsedAt: timestamptz
  predecessorEntityId: uuid
  statusText: String
  teamId: uuid
  type: String
  uniqueRef: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "entity"
"""
input entity_max_order_by {
  connectionId: order_by
  createdAt: order_by
  description: order_by
  hash: order_by
  id: order_by
  jobId: order_by
  parsedAt: order_by
  predecessorEntityId: order_by
  statusText: order_by
  teamId: order_by
  type: order_by
  uniqueRef: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type entity_min_fields {
  connectionId: uuid
  createdAt: timestamptz
  description: String
  hash: String
  id: uuid
  jobId: uuid
  parsedAt: timestamptz
  predecessorEntityId: uuid
  statusText: String
  teamId: uuid
  type: String
  uniqueRef: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "entity"
"""
input entity_min_order_by {
  connectionId: order_by
  createdAt: order_by
  description: order_by
  hash: order_by
  id: order_by
  jobId: order_by
  parsedAt: order_by
  predecessorEntityId: order_by
  statusText: order_by
  teamId: order_by
  type: order_by
  uniqueRef: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "entity"
"""
type entity_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [entity!]!
}

"""
input type for inserting object relation for remote table "entity"
"""
input entity_obj_rel_insert_input {
  data: entity_insert_input!

  """on conflict condition"""
  on_conflict: entity_on_conflict
}

"""
on conflict condition type for table "entity"
"""
input entity_on_conflict {
  constraint: entity_constraint!
  update_columns: [entity_update_column!]! = []
  where: entity_bool_exp
}

"""Ordering options when selecting data from "entity"."""
input entity_order_by {
  bookings_aggregate: booking_aggregate_order_by
  connection: connection_order_by
  connectionId: order_by
  createdAt: order_by
  description: order_by
  diffJson: order_by
  hash: order_by
  id: order_by
  job: job_order_by
  jobId: order_by
  json: order_by
  normalizedJson: order_by
  normalizedType: order_by
  parsedAt: order_by
  payments_aggregate: payment_aggregate_order_by
  predecessorEntity: entity_order_by
  predecessorEntityId: order_by
  status: order_by
  statusText: order_by
  successorEntities_aggregate: entity_aggregate_order_by
  team: team_order_by
  teamId: order_by
  type: order_by
  uniqueRef: order_by
  units_aggregate: unit_aggregate_order_by
  updatedAt: order_by
}

"""primary key columns input for table: entity"""
input entity_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input entity_prepend_input {
  diffJson: jsonb
  json: jsonb
  normalizedJson: jsonb
}

"""
select columns of table "entity"
"""
enum entity_select_column {
  """column name"""
  connectionId

  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  diffJson

  """column name"""
  hash

  """column name"""
  id

  """column name"""
  jobId

  """column name"""
  json

  """column name"""
  normalizedJson

  """column name"""
  normalizedType

  """column name"""
  parsedAt

  """column name"""
  predecessorEntityId

  """column name"""
  status

  """column name"""
  statusText

  """column name"""
  teamId

  """column name"""
  type

  """column name"""
  uniqueRef

  """column name"""
  updatedAt
}

"""
input type for updating data in table "entity"
"""
input entity_set_input {
  connectionId: uuid
  createdAt: timestamptz
  description: String
  diffJson: jsonb
  hash: String
  id: uuid
  jobId: uuid
  json: jsonb
  normalizedJson: jsonb
  normalizedType: normalized_type_enum
  parsedAt: timestamptz
  predecessorEntityId: uuid
  status: entity_status_enum
  statusText: String
  teamId: uuid
  type: String
  uniqueRef: String
  updatedAt: timestamptz
}

enum entity_status_enum {
  accepted
  extracted
  reconciled
  rejected
  transformed
}

"""
Boolean expression to compare columns of type "entity_status_enum". All fields are combined with logical 'AND'.
"""
input entity_status_enum_comparison_exp {
  _eq: entity_status_enum
  _in: [entity_status_enum!]
  _is_null: Boolean
  _neq: entity_status_enum
  _nin: [entity_status_enum!]
}

"""
update columns of table "entity"
"""
enum entity_update_column {
  """column name"""
  connectionId

  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  diffJson

  """column name"""
  hash

  """column name"""
  id

  """column name"""
  jobId

  """column name"""
  json

  """column name"""
  normalizedJson

  """column name"""
  normalizedType

  """column name"""
  parsedAt

  """column name"""
  predecessorEntityId

  """column name"""
  status

  """column name"""
  statusText

  """column name"""
  teamId

  """column name"""
  type

  """column name"""
  uniqueRef

  """column name"""
  updatedAt
}

"""
columns and relationships of "entity_status"
"""
type entityStatus {
  name: String!
}

"""
aggregated selection of "entity_status"
"""
type entityStatus_aggregate {
  aggregate: entityStatus_aggregate_fields
  nodes: [entityStatus!]!
}

"""
aggregate fields of "entity_status"
"""
type entityStatus_aggregate_fields {
  count(columns: [entityStatus_select_column!], distinct: Boolean): Int!
  max: entityStatus_max_fields
  min: entityStatus_min_fields
}

"""
Boolean expression to filter rows from the table "entity_status". All fields are combined with a logical 'AND'.
"""
input entityStatus_bool_exp {
  _and: [entityStatus_bool_exp!]
  _not: entityStatus_bool_exp
  _or: [entityStatus_bool_exp!]
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "entity_status"
"""
enum entityStatus_constraint {
  """unique or primary key constraint"""
  entity_status_pkey
}

"""
input type for inserting data into table "entity_status"
"""
input entityStatus_insert_input {
  name: String
}

"""aggregate max on columns"""
type entityStatus_max_fields {
  name: String
}

"""aggregate min on columns"""
type entityStatus_min_fields {
  name: String
}

"""
response of any mutation on the table "entity_status"
"""
type entityStatus_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [entityStatus!]!
}

"""
on conflict condition type for table "entity_status"
"""
input entityStatus_on_conflict {
  constraint: entityStatus_constraint!
  update_columns: [entityStatus_update_column!]! = []
  where: entityStatus_bool_exp
}

"""Ordering options when selecting data from "entity_status"."""
input entityStatus_order_by {
  name: order_by
}

"""primary key columns input for table: entityStatus"""
input entityStatus_pk_columns_input {
  name: String!
}

"""
select columns of table "entity_status"
"""
enum entityStatus_select_column {
  """column name"""
  name
}

"""
input type for updating data in table "entity_status"
"""
input entityStatus_set_input {
  name: String
}

"""
update columns of table "entity_status"
"""
enum entityStatus_update_column {
  """column name"""
  name
}

scalar float8

"""
Boolean expression to compare columns of type "float8". All fields are combined with logical 'AND'.
"""
input float8_comparison_exp {
  _eq: float8
  _gt: float8
  _gte: float8
  _in: [float8!]
  _is_null: Boolean
  _lt: float8
  _lte: float8
  _neq: float8
  _nin: [float8!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
columns and relationships of "integration"
"""
type integration {
  apiDevUrl: String
  apiUrl: String!

  """An array relationship"""
  connections(
    """distinct select on columns"""
    distinct_on: [connection_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [connection_order_by!]

    """filter the rows returned"""
    where: connection_bool_exp
  ): [connection!]!

  """An aggregate relationship"""
  connections_aggregate(
    """distinct select on columns"""
    distinct_on: [connection_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [connection_order_by!]

    """filter the rows returned"""
    where: connection_bool_exp
  ): connection_aggregate!
  icon: String
  id: uuid!
  isApproved: Boolean
  isPrivate: Boolean!

  """An array relationship"""
  jobs(
    """distinct select on columns"""
    distinct_on: [job_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [job_order_by!]

    """filter the rows returned"""
    where: job_bool_exp
  ): [job!]!

  """An aggregate relationship"""
  jobs_aggregate(
    """distinct select on columns"""
    distinct_on: [job_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [job_order_by!]

    """filter the rows returned"""
    where: job_bool_exp
  ): job_aggregate!
  name: String!

  """An object relationship"""
  team: team
  teamId: uuid
  type: integration_type_enum!
  uniqueRef: String!
}

"""
aggregated selection of "integration"
"""
type integration_aggregate {
  aggregate: integration_aggregate_fields
  nodes: [integration!]!
}

"""
aggregate fields of "integration"
"""
type integration_aggregate_fields {
  count(columns: [integration_select_column!], distinct: Boolean): Int!
  max: integration_max_fields
  min: integration_min_fields
}

"""
order by aggregate values of table "integration"
"""
input integration_aggregate_order_by {
  count: order_by
  max: integration_max_order_by
  min: integration_min_order_by
}

"""
input type for inserting array relation for remote table "integration"
"""
input integration_arr_rel_insert_input {
  data: [integration_insert_input!]!

  """on conflict condition"""
  on_conflict: integration_on_conflict
}

"""
Boolean expression to filter rows from the table "integration". All fields are combined with a logical 'AND'.
"""
input integration_bool_exp {
  _and: [integration_bool_exp!]
  _not: integration_bool_exp
  _or: [integration_bool_exp!]
  apiDevUrl: String_comparison_exp
  apiUrl: String_comparison_exp
  connections: connection_bool_exp
  icon: String_comparison_exp
  id: uuid_comparison_exp
  isApproved: Boolean_comparison_exp
  isPrivate: Boolean_comparison_exp
  jobs: job_bool_exp
  name: String_comparison_exp
  team: team_bool_exp
  teamId: uuid_comparison_exp
  type: integration_type_enum_comparison_exp
  uniqueRef: String_comparison_exp
}

"""
unique or primary key constraints on table "integration"
"""
enum integration_constraint {
  """unique or primary key constraint"""
  integration_pkey
}

"""
input type for inserting data into table "integration"
"""
input integration_insert_input {
  apiDevUrl: String
  apiUrl: String
  connections: connection_arr_rel_insert_input
  icon: String
  id: uuid
  isApproved: Boolean
  isPrivate: Boolean
  jobs: job_arr_rel_insert_input
  name: String
  team: team_obj_rel_insert_input
  teamId: uuid
  type: integration_type_enum
  uniqueRef: String
}

"""aggregate max on columns"""
type integration_max_fields {
  apiDevUrl: String
  apiUrl: String
  icon: String
  id: uuid
  name: String
  teamId: uuid
  uniqueRef: String
}

"""
order by max() on columns of table "integration"
"""
input integration_max_order_by {
  apiDevUrl: order_by
  apiUrl: order_by
  icon: order_by
  id: order_by
  name: order_by
  teamId: order_by
  uniqueRef: order_by
}

"""aggregate min on columns"""
type integration_min_fields {
  apiDevUrl: String
  apiUrl: String
  icon: String
  id: uuid
  name: String
  teamId: uuid
  uniqueRef: String
}

"""
order by min() on columns of table "integration"
"""
input integration_min_order_by {
  apiDevUrl: order_by
  apiUrl: order_by
  icon: order_by
  id: order_by
  name: order_by
  teamId: order_by
  uniqueRef: order_by
}

"""
response of any mutation on the table "integration"
"""
type integration_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [integration!]!
}

"""
input type for inserting object relation for remote table "integration"
"""
input integration_obj_rel_insert_input {
  data: integration_insert_input!

  """on conflict condition"""
  on_conflict: integration_on_conflict
}

"""
on conflict condition type for table "integration"
"""
input integration_on_conflict {
  constraint: integration_constraint!
  update_columns: [integration_update_column!]! = []
  where: integration_bool_exp
}

"""Ordering options when selecting data from "integration"."""
input integration_order_by {
  apiDevUrl: order_by
  apiUrl: order_by
  connections_aggregate: connection_aggregate_order_by
  icon: order_by
  id: order_by
  isApproved: order_by
  isPrivate: order_by
  jobs_aggregate: job_aggregate_order_by
  name: order_by
  team: team_order_by
  teamId: order_by
  type: order_by
  uniqueRef: order_by
}

"""primary key columns input for table: integration"""
input integration_pk_columns_input {
  id: uuid!
}

"""
select columns of table "integration"
"""
enum integration_select_column {
  """column name"""
  apiDevUrl

  """column name"""
  apiUrl

  """column name"""
  icon

  """column name"""
  id

  """column name"""
  isApproved

  """column name"""
  isPrivate

  """column name"""
  name

  """column name"""
  teamId

  """column name"""
  type

  """column name"""
  uniqueRef
}

"""
input type for updating data in table "integration"
"""
input integration_set_input {
  apiDevUrl: String
  apiUrl: String
  icon: String
  id: uuid
  isApproved: Boolean
  isPrivate: Boolean
  name: String
  teamId: uuid
  type: integration_type_enum
  uniqueRef: String
}

enum integration_type_enum {
  accountingPlatform
  bookingChannel
  otherService
  paymentGateway
  propertyManagementSystem
}

"""
Boolean expression to compare columns of type "integration_type_enum". All fields are combined with logical 'AND'.
"""
input integration_type_enum_comparison_exp {
  _eq: integration_type_enum
  _in: [integration_type_enum!]
  _is_null: Boolean
  _neq: integration_type_enum
  _nin: [integration_type_enum!]
}

"""
update columns of table "integration"
"""
enum integration_update_column {
  """column name"""
  apiDevUrl

  """column name"""
  apiUrl

  """column name"""
  icon

  """column name"""
  id

  """column name"""
  isApproved

  """column name"""
  isPrivate

  """column name"""
  name

  """column name"""
  teamId

  """column name"""
  type

  """column name"""
  uniqueRef
}

"""
columns and relationships of "integration_type"
"""
type integrationType {
  name: String!
}

"""
aggregated selection of "integration_type"
"""
type integrationType_aggregate {
  aggregate: integrationType_aggregate_fields
  nodes: [integrationType!]!
}

"""
aggregate fields of "integration_type"
"""
type integrationType_aggregate_fields {
  count(columns: [integrationType_select_column!], distinct: Boolean): Int!
  max: integrationType_max_fields
  min: integrationType_min_fields
}

"""
Boolean expression to filter rows from the table "integration_type". All fields are combined with a logical 'AND'.
"""
input integrationType_bool_exp {
  _and: [integrationType_bool_exp!]
  _not: integrationType_bool_exp
  _or: [integrationType_bool_exp!]
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "integration_type"
"""
enum integrationType_constraint {
  """unique or primary key constraint"""
  integration_type_pkey
}

"""
input type for inserting data into table "integration_type"
"""
input integrationType_insert_input {
  name: String
}

"""aggregate max on columns"""
type integrationType_max_fields {
  name: String
}

"""aggregate min on columns"""
type integrationType_min_fields {
  name: String
}

"""
response of any mutation on the table "integration_type"
"""
type integrationType_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [integrationType!]!
}

"""
on conflict condition type for table "integration_type"
"""
input integrationType_on_conflict {
  constraint: integrationType_constraint!
  update_columns: [integrationType_update_column!]! = []
  where: integrationType_bool_exp
}

"""Ordering options when selecting data from "integration_type"."""
input integrationType_order_by {
  name: order_by
}

"""primary key columns input for table: integrationType"""
input integrationType_pk_columns_input {
  name: String!
}

"""
select columns of table "integration_type"
"""
enum integrationType_select_column {
  """column name"""
  name
}

"""
input type for updating data in table "integration_type"
"""
input integrationType_set_input {
  name: String
}

"""
update columns of table "integration_type"
"""
enum integrationType_update_column {
  """column name"""
  name
}

"""
columns and relationships of "issue"
"""
type issue {
  code: String
  createdAt: timestamptz!
  id: uuid!
  isPublic: Boolean
  isResolved: Boolean

  """An object relationship"""
  job: job!
  jobId: uuid!
  message: String
  requestParams(
    """JSON select path"""
    path: String
  ): jsonb
  resolveParams(
    """JSON select path"""
    path: String
  ): jsonb

  """An object relationship"""
  team: team!
  teamId: uuid!
  type: String
  updatedAt: timestamptz!
}

"""
aggregated selection of "issue"
"""
type issue_aggregate {
  aggregate: issue_aggregate_fields
  nodes: [issue!]!
}

"""
aggregate fields of "issue"
"""
type issue_aggregate_fields {
  count(columns: [issue_select_column!], distinct: Boolean): Int!
  max: issue_max_fields
  min: issue_min_fields
}

"""
order by aggregate values of table "issue"
"""
input issue_aggregate_order_by {
  count: order_by
  max: issue_max_order_by
  min: issue_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input issue_append_input {
  requestParams: jsonb
  resolveParams: jsonb
}

"""
input type for inserting array relation for remote table "issue"
"""
input issue_arr_rel_insert_input {
  data: [issue_insert_input!]!

  """on conflict condition"""
  on_conflict: issue_on_conflict
}

"""
Boolean expression to filter rows from the table "issue". All fields are combined with a logical 'AND'.
"""
input issue_bool_exp {
  _and: [issue_bool_exp!]
  _not: issue_bool_exp
  _or: [issue_bool_exp!]
  code: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  isPublic: Boolean_comparison_exp
  isResolved: Boolean_comparison_exp
  job: job_bool_exp
  jobId: uuid_comparison_exp
  message: String_comparison_exp
  requestParams: jsonb_comparison_exp
  resolveParams: jsonb_comparison_exp
  team: team_bool_exp
  teamId: uuid_comparison_exp
  type: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "issue"
"""
enum issue_constraint {
  """unique or primary key constraint"""
  issue_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input issue_delete_at_path_input {
  requestParams: [String!]
  resolveParams: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input issue_delete_elem_input {
  requestParams: Int
  resolveParams: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input issue_delete_key_input {
  requestParams: String
  resolveParams: String
}

"""
input type for inserting data into table "issue"
"""
input issue_insert_input {
  code: String
  createdAt: timestamptz
  id: uuid
  isPublic: Boolean
  isResolved: Boolean
  job: job_obj_rel_insert_input
  jobId: uuid
  message: String
  requestParams: jsonb
  resolveParams: jsonb
  team: team_obj_rel_insert_input
  teamId: uuid
  type: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type issue_max_fields {
  code: String
  createdAt: timestamptz
  id: uuid
  jobId: uuid
  message: String
  teamId: uuid
  type: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "issue"
"""
input issue_max_order_by {
  code: order_by
  createdAt: order_by
  id: order_by
  jobId: order_by
  message: order_by
  teamId: order_by
  type: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type issue_min_fields {
  code: String
  createdAt: timestamptz
  id: uuid
  jobId: uuid
  message: String
  teamId: uuid
  type: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "issue"
"""
input issue_min_order_by {
  code: order_by
  createdAt: order_by
  id: order_by
  jobId: order_by
  message: order_by
  teamId: order_by
  type: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "issue"
"""
type issue_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [issue!]!
}

"""
on conflict condition type for table "issue"
"""
input issue_on_conflict {
  constraint: issue_constraint!
  update_columns: [issue_update_column!]! = []
  where: issue_bool_exp
}

"""Ordering options when selecting data from "issue"."""
input issue_order_by {
  code: order_by
  createdAt: order_by
  id: order_by
  isPublic: order_by
  isResolved: order_by
  job: job_order_by
  jobId: order_by
  message: order_by
  requestParams: order_by
  resolveParams: order_by
  team: team_order_by
  teamId: order_by
  type: order_by
  updatedAt: order_by
}

"""primary key columns input for table: issue"""
input issue_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input issue_prepend_input {
  requestParams: jsonb
  resolveParams: jsonb
}

"""
select columns of table "issue"
"""
enum issue_select_column {
  """column name"""
  code

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  isPublic

  """column name"""
  isResolved

  """column name"""
  jobId

  """column name"""
  message

  """column name"""
  requestParams

  """column name"""
  resolveParams

  """column name"""
  teamId

  """column name"""
  type

  """column name"""
  updatedAt
}

"""
input type for updating data in table "issue"
"""
input issue_set_input {
  code: String
  createdAt: timestamptz
  id: uuid
  isPublic: Boolean
  isResolved: Boolean
  jobId: uuid
  message: String
  requestParams: jsonb
  resolveParams: jsonb
  teamId: uuid
  type: String
  updatedAt: timestamptz
}

"""
update columns of table "issue"
"""
enum issue_update_column {
  """column name"""
  code

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  isPublic

  """column name"""
  isResolved

  """column name"""
  jobId

  """column name"""
  message

  """column name"""
  requestParams

  """column name"""
  resolveParams

  """column name"""
  teamId

  """column name"""
  type

  """column name"""
  updatedAt
}

"""
columns and relationships of "job"
"""
type job {
  apiVersion: String

  """An object relationship"""
  connection: connection
  connectionId: uuid
  createdAt: timestamptz!
  endedAt: timestamptz

  """An array relationship"""
  entities(
    """distinct select on columns"""
    distinct_on: [entity_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [entity_order_by!]

    """filter the rows returned"""
    where: entity_bool_exp
  ): [entity!]!

  """An aggregate relationship"""
  entities_aggregate(
    """distinct select on columns"""
    distinct_on: [entity_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [entity_order_by!]

    """filter the rows returned"""
    where: entity_bool_exp
  ): entity_aggregate!
  id: uuid!

  """An object relationship"""
  integration: integration
  integrationId: uuid
  integrationSdkVersion: String
  integrationVersion: String

  """An array relationship"""
  issues(
    """distinct select on columns"""
    distinct_on: [issue_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [issue_order_by!]

    """filter the rows returned"""
    where: issue_bool_exp
  ): [issue!]!

  """An aggregate relationship"""
  issues_aggregate(
    """distinct select on columns"""
    distinct_on: [issue_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [issue_order_by!]

    """filter the rows returned"""
    where: issue_bool_exp
  ): issue_aggregate!
  logFile: String
  logLink: String
  logs(
    """JSON select path"""
    path: String
  ): jsonb
  method: job_method_enum
  params(
    """JSON select path"""
    path: String
  ): jsonb
  requestId: String
  response(
    """JSON select path"""
    path: String
  ): jsonb
  sdkVersion: String
  startedAt: timestamptz
  status: job_status_enum

  """An object relationship"""
  team: team
  teamId: uuid
  updatedAt: timestamptz!
}

"""
aggregated selection of "job"
"""
type job_aggregate {
  aggregate: job_aggregate_fields
  nodes: [job!]!
}

"""
aggregate fields of "job"
"""
type job_aggregate_fields {
  count(columns: [job_select_column!], distinct: Boolean): Int!
  max: job_max_fields
  min: job_min_fields
}

"""
order by aggregate values of table "job"
"""
input job_aggregate_order_by {
  count: order_by
  max: job_max_order_by
  min: job_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input job_append_input {
  logs: jsonb
  params: jsonb
  response: jsonb
}

"""
input type for inserting array relation for remote table "job"
"""
input job_arr_rel_insert_input {
  data: [job_insert_input!]!

  """on conflict condition"""
  on_conflict: job_on_conflict
}

"""
Boolean expression to filter rows from the table "job". All fields are combined with a logical 'AND'.
"""
input job_bool_exp {
  _and: [job_bool_exp!]
  _not: job_bool_exp
  _or: [job_bool_exp!]
  apiVersion: String_comparison_exp
  connection: connection_bool_exp
  connectionId: uuid_comparison_exp
  createdAt: timestamptz_comparison_exp
  endedAt: timestamptz_comparison_exp
  entities: entity_bool_exp
  id: uuid_comparison_exp
  integration: integration_bool_exp
  integrationId: uuid_comparison_exp
  integrationSdkVersion: String_comparison_exp
  integrationVersion: String_comparison_exp
  issues: issue_bool_exp
  logFile: String_comparison_exp
  logLink: String_comparison_exp
  logs: jsonb_comparison_exp
  method: job_method_enum_comparison_exp
  params: jsonb_comparison_exp
  requestId: String_comparison_exp
  response: jsonb_comparison_exp
  sdkVersion: String_comparison_exp
  startedAt: timestamptz_comparison_exp
  status: job_status_enum_comparison_exp
  team: team_bool_exp
  teamId: uuid_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "job"
"""
enum job_constraint {
  """unique or primary key constraint"""
  job_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input job_delete_at_path_input {
  logs: [String!]
  params: [String!]
  response: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input job_delete_elem_input {
  logs: Int
  params: Int
  response: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input job_delete_key_input {
  logs: String
  params: String
  response: String
}

"""
input type for inserting data into table "job"
"""
input job_insert_input {
  apiVersion: String
  connection: connection_obj_rel_insert_input
  connectionId: uuid
  createdAt: timestamptz
  endedAt: timestamptz
  entities: entity_arr_rel_insert_input
  id: uuid
  integration: integration_obj_rel_insert_input
  integrationId: uuid
  integrationSdkVersion: String
  integrationVersion: String
  issues: issue_arr_rel_insert_input
  logFile: String
  logLink: String
  logs: jsonb
  method: job_method_enum
  params: jsonb
  requestId: String
  response: jsonb
  sdkVersion: String
  startedAt: timestamptz
  status: job_status_enum
  team: team_obj_rel_insert_input
  teamId: uuid
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type job_max_fields {
  apiVersion: String
  connectionId: uuid
  createdAt: timestamptz
  endedAt: timestamptz
  id: uuid
  integrationId: uuid
  integrationSdkVersion: String
  integrationVersion: String
  logFile: String
  logLink: String
  requestId: String
  sdkVersion: String
  startedAt: timestamptz
  teamId: uuid
  updatedAt: timestamptz
}

"""
order by max() on columns of table "job"
"""
input job_max_order_by {
  apiVersion: order_by
  connectionId: order_by
  createdAt: order_by
  endedAt: order_by
  id: order_by
  integrationId: order_by
  integrationSdkVersion: order_by
  integrationVersion: order_by
  logFile: order_by
  logLink: order_by
  requestId: order_by
  sdkVersion: order_by
  startedAt: order_by
  teamId: order_by
  updatedAt: order_by
}

enum job_method_enum {
  act
  connect
  delete
  enhance
  extract
  info
  react
  refresh
  transform
}

"""
Boolean expression to compare columns of type "job_method_enum". All fields are combined with logical 'AND'.
"""
input job_method_enum_comparison_exp {
  _eq: job_method_enum
  _in: [job_method_enum!]
  _is_null: Boolean
  _neq: job_method_enum
  _nin: [job_method_enum!]
}

"""aggregate min on columns"""
type job_min_fields {
  apiVersion: String
  connectionId: uuid
  createdAt: timestamptz
  endedAt: timestamptz
  id: uuid
  integrationId: uuid
  integrationSdkVersion: String
  integrationVersion: String
  logFile: String
  logLink: String
  requestId: String
  sdkVersion: String
  startedAt: timestamptz
  teamId: uuid
  updatedAt: timestamptz
}

"""
order by min() on columns of table "job"
"""
input job_min_order_by {
  apiVersion: order_by
  connectionId: order_by
  createdAt: order_by
  endedAt: order_by
  id: order_by
  integrationId: order_by
  integrationSdkVersion: order_by
  integrationVersion: order_by
  logFile: order_by
  logLink: order_by
  requestId: order_by
  sdkVersion: order_by
  startedAt: order_by
  teamId: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "job"
"""
type job_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [job!]!
}

"""
input type for inserting object relation for remote table "job"
"""
input job_obj_rel_insert_input {
  data: job_insert_input!

  """on conflict condition"""
  on_conflict: job_on_conflict
}

"""
on conflict condition type for table "job"
"""
input job_on_conflict {
  constraint: job_constraint!
  update_columns: [job_update_column!]! = []
  where: job_bool_exp
}

"""Ordering options when selecting data from "job"."""
input job_order_by {
  apiVersion: order_by
  connection: connection_order_by
  connectionId: order_by
  createdAt: order_by
  endedAt: order_by
  entities_aggregate: entity_aggregate_order_by
  id: order_by
  integration: integration_order_by
  integrationId: order_by
  integrationSdkVersion: order_by
  integrationVersion: order_by
  issues_aggregate: issue_aggregate_order_by
  logFile: order_by
  logLink: order_by
  logs: order_by
  method: order_by
  params: order_by
  requestId: order_by
  response: order_by
  sdkVersion: order_by
  startedAt: order_by
  status: order_by
  team: team_order_by
  teamId: order_by
  updatedAt: order_by
}

"""primary key columns input for table: job"""
input job_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input job_prepend_input {
  logs: jsonb
  params: jsonb
  response: jsonb
}

"""
select columns of table "job"
"""
enum job_select_column {
  """column name"""
  apiVersion

  """column name"""
  connectionId

  """column name"""
  createdAt

  """column name"""
  endedAt

  """column name"""
  id

  """column name"""
  integrationId

  """column name"""
  integrationSdkVersion

  """column name"""
  integrationVersion

  """column name"""
  logFile

  """column name"""
  logLink

  """column name"""
  logs

  """column name"""
  method

  """column name"""
  params

  """column name"""
  requestId

  """column name"""
  response

  """column name"""
  sdkVersion

  """column name"""
  startedAt

  """column name"""
  status

  """column name"""
  teamId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "job"
"""
input job_set_input {
  apiVersion: String
  connectionId: uuid
  createdAt: timestamptz
  endedAt: timestamptz
  id: uuid
  integrationId: uuid
  integrationSdkVersion: String
  integrationVersion: String
  logFile: String
  logLink: String
  logs: jsonb
  method: job_method_enum
  params: jsonb
  requestId: String
  response: jsonb
  sdkVersion: String
  startedAt: timestamptz
  status: job_status_enum
  teamId: uuid
  updatedAt: timestamptz
}

enum job_status_enum {
  completed
  failed
  paused
  queued
  started
}

"""
Boolean expression to compare columns of type "job_status_enum". All fields are combined with logical 'AND'.
"""
input job_status_enum_comparison_exp {
  _eq: job_status_enum
  _in: [job_status_enum!]
  _is_null: Boolean
  _neq: job_status_enum
  _nin: [job_status_enum!]
}

"""
update columns of table "job"
"""
enum job_update_column {
  """column name"""
  apiVersion

  """column name"""
  connectionId

  """column name"""
  createdAt

  """column name"""
  endedAt

  """column name"""
  id

  """column name"""
  integrationId

  """column name"""
  integrationSdkVersion

  """column name"""
  integrationVersion

  """column name"""
  logFile

  """column name"""
  logLink

  """column name"""
  logs

  """column name"""
  method

  """column name"""
  params

  """column name"""
  requestId

  """column name"""
  response

  """column name"""
  sdkVersion

  """column name"""
  startedAt

  """column name"""
  status

  """column name"""
  teamId

  """column name"""
  updatedAt
}

"""
columns and relationships of "job_method"
"""
type jobMethod {
  name: String!
}

"""
aggregated selection of "job_method"
"""
type jobMethod_aggregate {
  aggregate: jobMethod_aggregate_fields
  nodes: [jobMethod!]!
}

"""
aggregate fields of "job_method"
"""
type jobMethod_aggregate_fields {
  count(columns: [jobMethod_select_column!], distinct: Boolean): Int!
  max: jobMethod_max_fields
  min: jobMethod_min_fields
}

"""
Boolean expression to filter rows from the table "job_method". All fields are combined with a logical 'AND'.
"""
input jobMethod_bool_exp {
  _and: [jobMethod_bool_exp!]
  _not: jobMethod_bool_exp
  _or: [jobMethod_bool_exp!]
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "job_method"
"""
enum jobMethod_constraint {
  """unique or primary key constraint"""
  job_method_pkey
}

"""
input type for inserting data into table "job_method"
"""
input jobMethod_insert_input {
  name: String
}

"""aggregate max on columns"""
type jobMethod_max_fields {
  name: String
}

"""aggregate min on columns"""
type jobMethod_min_fields {
  name: String
}

"""
response of any mutation on the table "job_method"
"""
type jobMethod_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [jobMethod!]!
}

"""
on conflict condition type for table "job_method"
"""
input jobMethod_on_conflict {
  constraint: jobMethod_constraint!
  update_columns: [jobMethod_update_column!]! = []
  where: jobMethod_bool_exp
}

"""Ordering options when selecting data from "job_method"."""
input jobMethod_order_by {
  name: order_by
}

"""primary key columns input for table: jobMethod"""
input jobMethod_pk_columns_input {
  name: String!
}

"""
select columns of table "job_method"
"""
enum jobMethod_select_column {
  """column name"""
  name
}

"""
input type for updating data in table "job_method"
"""
input jobMethod_set_input {
  name: String
}

"""
update columns of table "job_method"
"""
enum jobMethod_update_column {
  """column name"""
  name
}

"""
columns and relationships of "job_status"
"""
type jobStatus {
  name: String!
}

"""
aggregated selection of "job_status"
"""
type jobStatus_aggregate {
  aggregate: jobStatus_aggregate_fields
  nodes: [jobStatus!]!
}

"""
aggregate fields of "job_status"
"""
type jobStatus_aggregate_fields {
  count(columns: [jobStatus_select_column!], distinct: Boolean): Int!
  max: jobStatus_max_fields
  min: jobStatus_min_fields
}

"""
Boolean expression to filter rows from the table "job_status". All fields are combined with a logical 'AND'.
"""
input jobStatus_bool_exp {
  _and: [jobStatus_bool_exp!]
  _not: jobStatus_bool_exp
  _or: [jobStatus_bool_exp!]
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "job_status"
"""
enum jobStatus_constraint {
  """unique or primary key constraint"""
  job_status_pkey
}

"""
input type for inserting data into table "job_status"
"""
input jobStatus_insert_input {
  name: String
}

"""aggregate max on columns"""
type jobStatus_max_fields {
  name: String
}

"""aggregate min on columns"""
type jobStatus_min_fields {
  name: String
}

"""
response of any mutation on the table "job_status"
"""
type jobStatus_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [jobStatus!]!
}

"""
on conflict condition type for table "job_status"
"""
input jobStatus_on_conflict {
  constraint: jobStatus_constraint!
  update_columns: [jobStatus_update_column!]! = []
  where: jobStatus_bool_exp
}

"""Ordering options when selecting data from "job_status"."""
input jobStatus_order_by {
  name: order_by
}

"""primary key columns input for table: jobStatus"""
input jobStatus_pk_columns_input {
  name: String!
}

"""
select columns of table "job_status"
"""
enum jobStatus_select_column {
  """column name"""
  name
}

"""
input type for updating data in table "job_status"
"""
input jobStatus_set_input {
  name: String
}

"""
update columns of table "job_status"
"""
enum jobStatus_update_column {
  """column name"""
  name
}

scalar jsonb

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""
columns and relationships of "line"
"""
type line {
  """An object relationship"""
  booking: booking
  bookingId: uuid
  centTotal: Int
  classification: classification_enum

  """An object relationship"""
  connection: connection
  connectionId: uuid
  createdAt: timestamptz!
  description: String

  """An array relationship"""
  enhancementLines(
    """distinct select on columns"""
    distinct_on: [line_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [line_order_by!]

    """filter the rows returned"""
    where: line_bool_exp
  ): [line!]!

  """An aggregate relationship"""
  enhancementLines_aggregate(
    """distinct select on columns"""
    distinct_on: [line_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [line_order_by!]

    """filter the rows returned"""
    where: line_bool_exp
  ): line_aggregate!

  """An object relationship"""
  enhancingLine: line
  enhancingLineId: uuid
  id: uuid!
  invoiceStatus: String
  isEnhanced: Boolean
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  originCentTotal: Int
  originCurrency: String
  originExchangeRate: numeric

  """An object relationship"""
  payment: payment
  paymentId: uuid
  subclassification: subclassification_enum

  """An object relationship"""
  team: team
  teamId: uuid
  type: String
  uniqueRef: String
  unitId: uuid
  updatedAt: timestamptz
}

"""
aggregated selection of "line"
"""
type line_aggregate {
  aggregate: line_aggregate_fields
  nodes: [line!]!
}

"""
aggregate fields of "line"
"""
type line_aggregate_fields {
  avg: line_avg_fields
  count(columns: [line_select_column!], distinct: Boolean): Int!
  max: line_max_fields
  min: line_min_fields
  stddev: line_stddev_fields
  stddev_pop: line_stddev_pop_fields
  stddev_samp: line_stddev_samp_fields
  sum: line_sum_fields
  var_pop: line_var_pop_fields
  var_samp: line_var_samp_fields
  variance: line_variance_fields
}

"""
order by aggregate values of table "line"
"""
input line_aggregate_order_by {
  avg: line_avg_order_by
  count: order_by
  max: line_max_order_by
  min: line_min_order_by
  stddev: line_stddev_order_by
  stddev_pop: line_stddev_pop_order_by
  stddev_samp: line_stddev_samp_order_by
  sum: line_sum_order_by
  var_pop: line_var_pop_order_by
  var_samp: line_var_samp_order_by
  variance: line_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input line_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "line"
"""
input line_arr_rel_insert_input {
  data: [line_insert_input!]!

  """on conflict condition"""
  on_conflict: line_on_conflict
}

"""aggregate avg on columns"""
type line_avg_fields {
  centTotal: Float
  originCentTotal: Float
  originExchangeRate: Float
}

"""
order by avg() on columns of table "line"
"""
input line_avg_order_by {
  centTotal: order_by
  originCentTotal: order_by
  originExchangeRate: order_by
}

"""
Boolean expression to filter rows from the table "line". All fields are combined with a logical 'AND'.
"""
input line_bool_exp {
  _and: [line_bool_exp!]
  _not: line_bool_exp
  _or: [line_bool_exp!]
  booking: booking_bool_exp
  bookingId: uuid_comparison_exp
  centTotal: Int_comparison_exp
  classification: classification_enum_comparison_exp
  connection: connection_bool_exp
  connectionId: uuid_comparison_exp
  createdAt: timestamptz_comparison_exp
  description: String_comparison_exp
  enhancementLines: line_bool_exp
  enhancingLine: line_bool_exp
  enhancingLineId: uuid_comparison_exp
  id: uuid_comparison_exp
  invoiceStatus: String_comparison_exp
  isEnhanced: Boolean_comparison_exp
  metadata: jsonb_comparison_exp
  originCentTotal: Int_comparison_exp
  originCurrency: String_comparison_exp
  originExchangeRate: numeric_comparison_exp
  payment: payment_bool_exp
  paymentId: uuid_comparison_exp
  subclassification: subclassification_enum_comparison_exp
  team: team_bool_exp
  teamId: uuid_comparison_exp
  type: String_comparison_exp
  uniqueRef: String_comparison_exp
  unitId: uuid_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "line"
"""
enum line_constraint {
  """unique or primary key constraint"""
  line_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input line_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input line_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input line_delete_key_input {
  metadata: String
}

"""
input type for incrementing numeric columns in table "line"
"""
input line_inc_input {
  centTotal: Int
  originCentTotal: Int
  originExchangeRate: numeric
}

"""
input type for inserting data into table "line"
"""
input line_insert_input {
  booking: booking_obj_rel_insert_input
  bookingId: uuid
  centTotal: Int
  classification: classification_enum
  connection: connection_obj_rel_insert_input
  connectionId: uuid
  createdAt: timestamptz
  description: String
  enhancementLines: line_arr_rel_insert_input
  enhancingLine: line_obj_rel_insert_input
  enhancingLineId: uuid
  id: uuid
  invoiceStatus: String
  isEnhanced: Boolean
  metadata: jsonb
  originCentTotal: Int
  originCurrency: String
  originExchangeRate: numeric
  payment: payment_obj_rel_insert_input
  paymentId: uuid
  subclassification: subclassification_enum
  team: team_obj_rel_insert_input
  teamId: uuid
  type: String
  uniqueRef: String
  unitId: uuid
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type line_max_fields {
  bookingId: uuid
  centTotal: Int
  connectionId: uuid
  createdAt: timestamptz
  description: String
  enhancingLineId: uuid
  id: uuid
  invoiceStatus: String
  originCentTotal: Int
  originCurrency: String
  originExchangeRate: numeric
  paymentId: uuid
  teamId: uuid
  type: String
  uniqueRef: String
  unitId: uuid
  updatedAt: timestamptz
}

"""
order by max() on columns of table "line"
"""
input line_max_order_by {
  bookingId: order_by
  centTotal: order_by
  connectionId: order_by
  createdAt: order_by
  description: order_by
  enhancingLineId: order_by
  id: order_by
  invoiceStatus: order_by
  originCentTotal: order_by
  originCurrency: order_by
  originExchangeRate: order_by
  paymentId: order_by
  teamId: order_by
  type: order_by
  uniqueRef: order_by
  unitId: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type line_min_fields {
  bookingId: uuid
  centTotal: Int
  connectionId: uuid
  createdAt: timestamptz
  description: String
  enhancingLineId: uuid
  id: uuid
  invoiceStatus: String
  originCentTotal: Int
  originCurrency: String
  originExchangeRate: numeric
  paymentId: uuid
  teamId: uuid
  type: String
  uniqueRef: String
  unitId: uuid
  updatedAt: timestamptz
}

"""
order by min() on columns of table "line"
"""
input line_min_order_by {
  bookingId: order_by
  centTotal: order_by
  connectionId: order_by
  createdAt: order_by
  description: order_by
  enhancingLineId: order_by
  id: order_by
  invoiceStatus: order_by
  originCentTotal: order_by
  originCurrency: order_by
  originExchangeRate: order_by
  paymentId: order_by
  teamId: order_by
  type: order_by
  uniqueRef: order_by
  unitId: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "line"
"""
type line_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [line!]!
}

"""
input type for inserting object relation for remote table "line"
"""
input line_obj_rel_insert_input {
  data: line_insert_input!

  """on conflict condition"""
  on_conflict: line_on_conflict
}

"""
on conflict condition type for table "line"
"""
input line_on_conflict {
  constraint: line_constraint!
  update_columns: [line_update_column!]! = []
  where: line_bool_exp
}

"""Ordering options when selecting data from "line"."""
input line_order_by {
  booking: booking_order_by
  bookingId: order_by
  centTotal: order_by
  classification: order_by
  connection: connection_order_by
  connectionId: order_by
  createdAt: order_by
  description: order_by
  enhancementLines_aggregate: line_aggregate_order_by
  enhancingLine: line_order_by
  enhancingLineId: order_by
  id: order_by
  invoiceStatus: order_by
  isEnhanced: order_by
  metadata: order_by
  originCentTotal: order_by
  originCurrency: order_by
  originExchangeRate: order_by
  payment: payment_order_by
  paymentId: order_by
  subclassification: order_by
  team: team_order_by
  teamId: order_by
  type: order_by
  uniqueRef: order_by
  unitId: order_by
  updatedAt: order_by
}

"""primary key columns input for table: line"""
input line_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input line_prepend_input {
  metadata: jsonb
}

"""
select columns of table "line"
"""
enum line_select_column {
  """column name"""
  bookingId

  """column name"""
  centTotal

  """column name"""
  classification

  """column name"""
  connectionId

  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  enhancingLineId

  """column name"""
  id

  """column name"""
  invoiceStatus

  """column name"""
  isEnhanced

  """column name"""
  metadata

  """column name"""
  originCentTotal

  """column name"""
  originCurrency

  """column name"""
  originExchangeRate

  """column name"""
  paymentId

  """column name"""
  subclassification

  """column name"""
  teamId

  """column name"""
  type

  """column name"""
  uniqueRef

  """column name"""
  unitId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "line"
"""
input line_set_input {
  bookingId: uuid
  centTotal: Int
  classification: classification_enum
  connectionId: uuid
  createdAt: timestamptz
  description: String
  enhancingLineId: uuid
  id: uuid
  invoiceStatus: String
  isEnhanced: Boolean
  metadata: jsonb
  originCentTotal: Int
  originCurrency: String
  originExchangeRate: numeric
  paymentId: uuid
  subclassification: subclassification_enum
  teamId: uuid
  type: String
  uniqueRef: String
  unitId: uuid
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type line_stddev_fields {
  centTotal: Float
  originCentTotal: Float
  originExchangeRate: Float
}

"""
order by stddev() on columns of table "line"
"""
input line_stddev_order_by {
  centTotal: order_by
  originCentTotal: order_by
  originExchangeRate: order_by
}

"""aggregate stddev_pop on columns"""
type line_stddev_pop_fields {
  centTotal: Float
  originCentTotal: Float
  originExchangeRate: Float
}

"""
order by stddev_pop() on columns of table "line"
"""
input line_stddev_pop_order_by {
  centTotal: order_by
  originCentTotal: order_by
  originExchangeRate: order_by
}

"""aggregate stddev_samp on columns"""
type line_stddev_samp_fields {
  centTotal: Float
  originCentTotal: Float
  originExchangeRate: Float
}

"""
order by stddev_samp() on columns of table "line"
"""
input line_stddev_samp_order_by {
  centTotal: order_by
  originCentTotal: order_by
  originExchangeRate: order_by
}

"""aggregate sum on columns"""
type line_sum_fields {
  centTotal: Int
  originCentTotal: Int
  originExchangeRate: numeric
}

"""
order by sum() on columns of table "line"
"""
input line_sum_order_by {
  centTotal: order_by
  originCentTotal: order_by
  originExchangeRate: order_by
}

"""
update columns of table "line"
"""
enum line_update_column {
  """column name"""
  bookingId

  """column name"""
  centTotal

  """column name"""
  classification

  """column name"""
  connectionId

  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  enhancingLineId

  """column name"""
  id

  """column name"""
  invoiceStatus

  """column name"""
  isEnhanced

  """column name"""
  metadata

  """column name"""
  originCentTotal

  """column name"""
  originCurrency

  """column name"""
  originExchangeRate

  """column name"""
  paymentId

  """column name"""
  subclassification

  """column name"""
  teamId

  """column name"""
  type

  """column name"""
  uniqueRef

  """column name"""
  unitId

  """column name"""
  updatedAt
}

"""aggregate var_pop on columns"""
type line_var_pop_fields {
  centTotal: Float
  originCentTotal: Float
  originExchangeRate: Float
}

"""
order by var_pop() on columns of table "line"
"""
input line_var_pop_order_by {
  centTotal: order_by
  originCentTotal: order_by
  originExchangeRate: order_by
}

"""aggregate var_samp on columns"""
type line_var_samp_fields {
  centTotal: Float
  originCentTotal: Float
  originExchangeRate: Float
}

"""
order by var_samp() on columns of table "line"
"""
input line_var_samp_order_by {
  centTotal: order_by
  originCentTotal: order_by
  originExchangeRate: order_by
}

"""aggregate variance on columns"""
type line_variance_fields {
  centTotal: Float
  originCentTotal: Float
  originExchangeRate: Float
}

"""
order by variance() on columns of table "line"
"""
input line_variance_order_by {
  centTotal: order_by
  originCentTotal: order_by
  originExchangeRate: order_by
}

"""
columns and relationships of "metric"
"""
type metric {
  """An object relationship"""
  connection: connection!
  connectionId: uuid!
  createdAt: timestamptz!
  ensuedAt: timestamptz!
  id: uuid!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb!

  """An object relationship"""
  team: team!
  teamId: uuid!
  text: String
  type: String!
  uniqueRef: String
  unitId: uuid
  updatedAt: timestamptz!
  value: float8
}

"""
aggregated selection of "metric"
"""
type metric_aggregate {
  aggregate: metric_aggregate_fields
  nodes: [metric!]!
}

"""
aggregate fields of "metric"
"""
type metric_aggregate_fields {
  avg: metric_avg_fields
  count(columns: [metric_select_column!], distinct: Boolean): Int!
  max: metric_max_fields
  min: metric_min_fields
  stddev: metric_stddev_fields
  stddev_pop: metric_stddev_pop_fields
  stddev_samp: metric_stddev_samp_fields
  sum: metric_sum_fields
  var_pop: metric_var_pop_fields
  var_samp: metric_var_samp_fields
  variance: metric_variance_fields
}

"""
order by aggregate values of table "metric"
"""
input metric_aggregate_order_by {
  avg: metric_avg_order_by
  count: order_by
  max: metric_max_order_by
  min: metric_min_order_by
  stddev: metric_stddev_order_by
  stddev_pop: metric_stddev_pop_order_by
  stddev_samp: metric_stddev_samp_order_by
  sum: metric_sum_order_by
  var_pop: metric_var_pop_order_by
  var_samp: metric_var_samp_order_by
  variance: metric_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input metric_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "metric"
"""
input metric_arr_rel_insert_input {
  data: [metric_insert_input!]!

  """on conflict condition"""
  on_conflict: metric_on_conflict
}

"""aggregate avg on columns"""
type metric_avg_fields {
  value: Float
}

"""
order by avg() on columns of table "metric"
"""
input metric_avg_order_by {
  value: order_by
}

"""
Boolean expression to filter rows from the table "metric". All fields are combined with a logical 'AND'.
"""
input metric_bool_exp {
  _and: [metric_bool_exp!]
  _not: metric_bool_exp
  _or: [metric_bool_exp!]
  connection: connection_bool_exp
  connectionId: uuid_comparison_exp
  createdAt: timestamptz_comparison_exp
  ensuedAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  metadata: jsonb_comparison_exp
  team: team_bool_exp
  teamId: uuid_comparison_exp
  text: String_comparison_exp
  type: String_comparison_exp
  uniqueRef: String_comparison_exp
  unitId: uuid_comparison_exp
  updatedAt: timestamptz_comparison_exp
  value: float8_comparison_exp
}

"""
unique or primary key constraints on table "metric"
"""
enum metric_constraint {
  """unique or primary key constraint"""
  metric_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input metric_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input metric_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input metric_delete_key_input {
  metadata: String
}

"""
input type for incrementing numeric columns in table "metric"
"""
input metric_inc_input {
  value: float8
}

"""
input type for inserting data into table "metric"
"""
input metric_insert_input {
  connection: connection_obj_rel_insert_input
  connectionId: uuid
  createdAt: timestamptz
  ensuedAt: timestamptz
  id: uuid
  metadata: jsonb
  team: team_obj_rel_insert_input
  teamId: uuid
  text: String
  type: String
  uniqueRef: String
  unitId: uuid
  updatedAt: timestamptz
  value: float8
}

"""aggregate max on columns"""
type metric_max_fields {
  connectionId: uuid
  createdAt: timestamptz
  ensuedAt: timestamptz
  id: uuid
  teamId: uuid
  text: String
  type: String
  uniqueRef: String
  unitId: uuid
  updatedAt: timestamptz
  value: float8
}

"""
order by max() on columns of table "metric"
"""
input metric_max_order_by {
  connectionId: order_by
  createdAt: order_by
  ensuedAt: order_by
  id: order_by
  teamId: order_by
  text: order_by
  type: order_by
  uniqueRef: order_by
  unitId: order_by
  updatedAt: order_by
  value: order_by
}

"""aggregate min on columns"""
type metric_min_fields {
  connectionId: uuid
  createdAt: timestamptz
  ensuedAt: timestamptz
  id: uuid
  teamId: uuid
  text: String
  type: String
  uniqueRef: String
  unitId: uuid
  updatedAt: timestamptz
  value: float8
}

"""
order by min() on columns of table "metric"
"""
input metric_min_order_by {
  connectionId: order_by
  createdAt: order_by
  ensuedAt: order_by
  id: order_by
  teamId: order_by
  text: order_by
  type: order_by
  uniqueRef: order_by
  unitId: order_by
  updatedAt: order_by
  value: order_by
}

"""
response of any mutation on the table "metric"
"""
type metric_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [metric!]!
}

"""
on conflict condition type for table "metric"
"""
input metric_on_conflict {
  constraint: metric_constraint!
  update_columns: [metric_update_column!]! = []
  where: metric_bool_exp
}

"""Ordering options when selecting data from "metric"."""
input metric_order_by {
  connection: connection_order_by
  connectionId: order_by
  createdAt: order_by
  ensuedAt: order_by
  id: order_by
  metadata: order_by
  team: team_order_by
  teamId: order_by
  text: order_by
  type: order_by
  uniqueRef: order_by
  unitId: order_by
  updatedAt: order_by
  value: order_by
}

"""primary key columns input for table: metric"""
input metric_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input metric_prepend_input {
  metadata: jsonb
}

"""
select columns of table "metric"
"""
enum metric_select_column {
  """column name"""
  connectionId

  """column name"""
  createdAt

  """column name"""
  ensuedAt

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  teamId

  """column name"""
  text

  """column name"""
  type

  """column name"""
  uniqueRef

  """column name"""
  unitId

  """column name"""
  updatedAt

  """column name"""
  value
}

"""
input type for updating data in table "metric"
"""
input metric_set_input {
  connectionId: uuid
  createdAt: timestamptz
  ensuedAt: timestamptz
  id: uuid
  metadata: jsonb
  teamId: uuid
  text: String
  type: String
  uniqueRef: String
  unitId: uuid
  updatedAt: timestamptz
  value: float8
}

"""aggregate stddev on columns"""
type metric_stddev_fields {
  value: Float
}

"""
order by stddev() on columns of table "metric"
"""
input metric_stddev_order_by {
  value: order_by
}

"""aggregate stddev_pop on columns"""
type metric_stddev_pop_fields {
  value: Float
}

"""
order by stddev_pop() on columns of table "metric"
"""
input metric_stddev_pop_order_by {
  value: order_by
}

"""aggregate stddev_samp on columns"""
type metric_stddev_samp_fields {
  value: Float
}

"""
order by stddev_samp() on columns of table "metric"
"""
input metric_stddev_samp_order_by {
  value: order_by
}

"""aggregate sum on columns"""
type metric_sum_fields {
  value: float8
}

"""
order by sum() on columns of table "metric"
"""
input metric_sum_order_by {
  value: order_by
}

"""
update columns of table "metric"
"""
enum metric_update_column {
  """column name"""
  connectionId

  """column name"""
  createdAt

  """column name"""
  ensuedAt

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  teamId

  """column name"""
  text

  """column name"""
  type

  """column name"""
  uniqueRef

  """column name"""
  unitId

  """column name"""
  updatedAt

  """column name"""
  value
}

"""aggregate var_pop on columns"""
type metric_var_pop_fields {
  value: Float
}

"""
order by var_pop() on columns of table "metric"
"""
input metric_var_pop_order_by {
  value: order_by
}

"""aggregate var_samp on columns"""
type metric_var_samp_fields {
  value: Float
}

"""
order by var_samp() on columns of table "metric"
"""
input metric_var_samp_order_by {
  value: order_by
}

"""aggregate variance on columns"""
type metric_variance_fields {
  value: Float
}

"""
order by variance() on columns of table "metric"
"""
input metric_variance_order_by {
  value: order_by
}

"""mutation root"""
type mutation_root {
  """
  delete single row from the table: "booking"
  """
  deleteBooking(id: uuid!): booking

  """
  delete single row from the table: "booking_status"
  """
  deleteBookingStatus(name: String!): bookingStatus

  """
  delete data from the table: "booking_status"
  """
  deleteBookingStatuses(
    """filter the rows which have to be deleted"""
    where: bookingStatus_bool_exp!
  ): bookingStatus_mutation_response

  """
  delete data from the table: "booking"
  """
  deleteBookings(
    """filter the rows which have to be deleted"""
    where: booking_bool_exp!
  ): booking_mutation_response

  """
  delete single row from the table: "classification"
  """
  deleteClassification(name: String!): classification

  """
  delete data from the table: "classification"
  """
  deleteClassifications(
    """filter the rows which have to be deleted"""
    where: classification_bool_exp!
  ): classification_mutation_response

  """
  delete single row from the table: "connection"
  """
  deleteConnection(id: uuid!): connection

  """
  delete data from the table: "connection"
  """
  deleteConnections(
    """filter the rows which have to be deleted"""
    where: connection_bool_exp!
  ): connection_mutation_response

  """
  delete data from the table: "currency"
  """
  deleteCurrencies(
    """filter the rows which have to be deleted"""
    where: currency_bool_exp!
  ): currency_mutation_response

  """
  delete single row from the table: "currency"
  """
  deleteCurrency(name: String!): currency

  """
  delete data from the table: "entity"
  """
  deleteEntities(
    """filter the rows which have to be deleted"""
    where: entity_bool_exp!
  ): entity_mutation_response

  """
  delete single row from the table: "entity"
  """
  deleteEntity(id: uuid!): entity

  """
  delete single row from the table: "entity_status"
  """
  deleteEntityStatus(name: String!): entityStatus

  """
  delete data from the table: "entity_status"
  """
  deleteEntityStatuses(
    """filter the rows which have to be deleted"""
    where: entityStatus_bool_exp!
  ): entityStatus_mutation_response

  """
  delete single row from the table: "integration"
  """
  deleteIntegration(id: uuid!): integration

  """
  delete single row from the table: "integration_type"
  """
  deleteIntegrationType(name: String!): integrationType

  """
  delete data from the table: "integration_type"
  """
  deleteIntegrationTypes(
    """filter the rows which have to be deleted"""
    where: integrationType_bool_exp!
  ): integrationType_mutation_response

  """
  delete data from the table: "integration"
  """
  deleteIntegrations(
    """filter the rows which have to be deleted"""
    where: integration_bool_exp!
  ): integration_mutation_response

  """
  delete single row from the table: "issue"
  """
  deleteIssue(id: uuid!): issue

  """
  delete data from the table: "issue"
  """
  deleteIssues(
    """filter the rows which have to be deleted"""
    where: issue_bool_exp!
  ): issue_mutation_response

  """
  delete single row from the table: "job"
  """
  deleteJob(id: uuid!): job

  """
  delete single row from the table: "job_method"
  """
  deleteJobMethod(name: String!): jobMethod

  """
  delete data from the table: "job_method"
  """
  deleteJobMethods(
    """filter the rows which have to be deleted"""
    where: jobMethod_bool_exp!
  ): jobMethod_mutation_response

  """
  delete single row from the table: "job_status"
  """
  deleteJobStatus(name: String!): jobStatus

  """
  delete data from the table: "job_status"
  """
  deleteJobStatuses(
    """filter the rows which have to be deleted"""
    where: jobStatus_bool_exp!
  ): jobStatus_mutation_response

  """
  delete data from the table: "job"
  """
  deleteJobs(
    """filter the rows which have to be deleted"""
    where: job_bool_exp!
  ): job_mutation_response

  """
  delete single row from the table: "line"
  """
  deleteLine(id: uuid!): line

  """
  delete data from the table: "line"
  """
  deleteLines(
    """filter the rows which have to be deleted"""
    where: line_bool_exp!
  ): line_mutation_response

  """
  delete single row from the table: "metric"
  """
  deleteMetric(id: uuid!): metric

  """
  delete data from the table: "metric"
  """
  deleteMetrics(
    """filter the rows which have to be deleted"""
    where: metric_bool_exp!
  ): metric_mutation_response

  """
  delete single row from the table: "normalized_type"
  """
  deleteNormalizedType(name: String!): normalizedType

  """
  delete data from the table: "normalized_type"
  """
  deleteNormalizedTypes(
    """filter the rows which have to be deleted"""
    where: normalizedType_bool_exp!
  ): normalizedType_mutation_response

  """
  delete single row from the table: "payment"
  """
  deletePayment(id: uuid!): payment

  """
  delete single row from the table: "payment_status"
  """
  deletePaymentStatus(name: String!): paymentStatus

  """
  delete data from the table: "payment_status"
  """
  deletePaymentStatuses(
    """filter the rows which have to be deleted"""
    where: paymentStatus_bool_exp!
  ): paymentStatus_mutation_response

  """
  delete single row from the table: "payment_type"
  """
  deletePaymentType(name: String!): paymentType

  """
  delete data from the table: "payment_type"
  """
  deletePaymentTypes(
    """filter the rows which have to be deleted"""
    where: paymentType_bool_exp!
  ): paymentType_mutation_response

  """
  delete data from the table: "payment"
  """
  deletePayments(
    """filter the rows which have to be deleted"""
    where: payment_bool_exp!
  ): payment_mutation_response

  """
  delete single row from the table: "subclassification"
  """
  deleteSubclassification(name: String!): subclassification

  """
  delete data from the table: "subclassification"
  """
  deleteSubclassifications(
    """filter the rows which have to be deleted"""
    where: subclassification_bool_exp!
  ): subclassification_mutation_response

  """
  delete single row from the table: "tag"
  """
  deleteTag(id: uuid!): tag

  """
  delete data from the table: "tag"
  """
  deleteTags(
    """filter the rows which have to be deleted"""
    where: tag_bool_exp!
  ): tag_mutation_response

  """
  delete single row from the table: "team"
  """
  deleteTeam(id: uuid!): team

  """
  delete single row from the table: "team_user"
  """
  deleteTeamUser(id: uuid!): teamUser

  """
  delete data from the table: "team_user"
  """
  deleteTeamUsers(
    """filter the rows which have to be deleted"""
    where: teamUser_bool_exp!
  ): teamUser_mutation_response

  """
  delete data from the table: "team"
  """
  deleteTeams(
    """filter the rows which have to be deleted"""
    where: team_bool_exp!
  ): team_mutation_response

  """
  delete single row from the table: "unit"
  """
  deleteUnit(id: uuid!): unit

  """
  delete data from the table: "unit"
  """
  deleteUnits(
    """filter the rows which have to be deleted"""
    where: unit_bool_exp!
  ): unit_mutation_response

  """
  delete single row from the table: "user"
  """
  deleteUser(id: uuid!): user

  """
  delete single row from the table: "user_status"
  """
  deleteUserStatus(name: String!): userStatus

  """
  delete data from the table: "user_status"
  """
  deleteUserStatuses(
    """filter the rows which have to be deleted"""
    where: userStatus_bool_exp!
  ): userStatus_mutation_response

  """
  delete data from the table: "user"
  """
  deleteUsers(
    """filter the rows which have to be deleted"""
    where: user_bool_exp!
  ): user_mutation_response

  """
  delete single row from the table: "webhook"
  """
  deleteWebhook(id: uuid!): webhook

  """
  delete data from the table: "webhook"
  """
  deleteWebhooks(
    """filter the rows which have to be deleted"""
    where: webhook_bool_exp!
  ): webhook_mutation_response

  """
  delete data from the table: "booking_channel"
  """
  delete_booking_channel(
    """filter the rows which have to be deleted"""
    where: booking_channel_bool_exp!
  ): booking_channel_mutation_response

  """
  delete single row from the table: "booking_channel"
  """
  delete_booking_channel_by_pk(name: String!): booking_channel

  """
  insert a single row into the table: "booking"
  """
  insertBooking(
    """the row to be inserted"""
    object: booking_insert_input!

    """on conflict condition"""
    on_conflict: booking_on_conflict
  ): booking

  """
  insert a single row into the table: "booking_status"
  """
  insertBookingStatus(
    """the row to be inserted"""
    object: bookingStatus_insert_input!

    """on conflict condition"""
    on_conflict: bookingStatus_on_conflict
  ): bookingStatus

  """
  insert data into the table: "booking_status"
  """
  insertBookingStatuses(
    """the rows to be inserted"""
    objects: [bookingStatus_insert_input!]!

    """on conflict condition"""
    on_conflict: bookingStatus_on_conflict
  ): bookingStatus_mutation_response

  """
  insert data into the table: "booking"
  """
  insertBookings(
    """the rows to be inserted"""
    objects: [booking_insert_input!]!

    """on conflict condition"""
    on_conflict: booking_on_conflict
  ): booking_mutation_response

  """
  insert a single row into the table: "classification"
  """
  insertClassification(
    """the row to be inserted"""
    object: classification_insert_input!

    """on conflict condition"""
    on_conflict: classification_on_conflict
  ): classification

  """
  insert data into the table: "classification"
  """
  insertClassifications(
    """the rows to be inserted"""
    objects: [classification_insert_input!]!

    """on conflict condition"""
    on_conflict: classification_on_conflict
  ): classification_mutation_response

  """
  insert a single row into the table: "connection"
  """
  insertConnection(
    """the row to be inserted"""
    object: connection_insert_input!

    """on conflict condition"""
    on_conflict: connection_on_conflict
  ): connection

  """
  insert data into the table: "connection"
  """
  insertConnections(
    """the rows to be inserted"""
    objects: [connection_insert_input!]!

    """on conflict condition"""
    on_conflict: connection_on_conflict
  ): connection_mutation_response

  """
  insert data into the table: "currency"
  """
  insertCurrencies(
    """the rows to be inserted"""
    objects: [currency_insert_input!]!

    """on conflict condition"""
    on_conflict: currency_on_conflict
  ): currency_mutation_response

  """
  insert a single row into the table: "currency"
  """
  insertCurrency(
    """the row to be inserted"""
    object: currency_insert_input!

    """on conflict condition"""
    on_conflict: currency_on_conflict
  ): currency

  """
  insert data into the table: "entity"
  """
  insertEntities(
    """the rows to be inserted"""
    objects: [entity_insert_input!]!

    """on conflict condition"""
    on_conflict: entity_on_conflict
  ): entity_mutation_response

  """
  insert a single row into the table: "entity"
  """
  insertEntity(
    """the row to be inserted"""
    object: entity_insert_input!

    """on conflict condition"""
    on_conflict: entity_on_conflict
  ): entity

  """
  insert a single row into the table: "entity_status"
  """
  insertEntityStatus(
    """the row to be inserted"""
    object: entityStatus_insert_input!

    """on conflict condition"""
    on_conflict: entityStatus_on_conflict
  ): entityStatus

  """
  insert data into the table: "entity_status"
  """
  insertEntityStatuses(
    """the rows to be inserted"""
    objects: [entityStatus_insert_input!]!

    """on conflict condition"""
    on_conflict: entityStatus_on_conflict
  ): entityStatus_mutation_response

  """
  insert a single row into the table: "integration"
  """
  insertIntegration(
    """the row to be inserted"""
    object: integration_insert_input!

    """on conflict condition"""
    on_conflict: integration_on_conflict
  ): integration

  """
  insert a single row into the table: "integration_type"
  """
  insertIntegrationType(
    """the row to be inserted"""
    object: integrationType_insert_input!

    """on conflict condition"""
    on_conflict: integrationType_on_conflict
  ): integrationType

  """
  insert data into the table: "integration_type"
  """
  insertIntegrationTypes(
    """the rows to be inserted"""
    objects: [integrationType_insert_input!]!

    """on conflict condition"""
    on_conflict: integrationType_on_conflict
  ): integrationType_mutation_response

  """
  insert data into the table: "integration"
  """
  insertIntegrations(
    """the rows to be inserted"""
    objects: [integration_insert_input!]!

    """on conflict condition"""
    on_conflict: integration_on_conflict
  ): integration_mutation_response

  """
  insert a single row into the table: "issue"
  """
  insertIssue(
    """the row to be inserted"""
    object: issue_insert_input!

    """on conflict condition"""
    on_conflict: issue_on_conflict
  ): issue

  """
  insert data into the table: "issue"
  """
  insertIssues(
    """the rows to be inserted"""
    objects: [issue_insert_input!]!

    """on conflict condition"""
    on_conflict: issue_on_conflict
  ): issue_mutation_response

  """
  insert a single row into the table: "job"
  """
  insertJob(
    """the row to be inserted"""
    object: job_insert_input!

    """on conflict condition"""
    on_conflict: job_on_conflict
  ): job

  """
  insert a single row into the table: "job_method"
  """
  insertJobMethod(
    """the row to be inserted"""
    object: jobMethod_insert_input!

    """on conflict condition"""
    on_conflict: jobMethod_on_conflict
  ): jobMethod

  """
  insert data into the table: "job_method"
  """
  insertJobMethods(
    """the rows to be inserted"""
    objects: [jobMethod_insert_input!]!

    """on conflict condition"""
    on_conflict: jobMethod_on_conflict
  ): jobMethod_mutation_response

  """
  insert a single row into the table: "job_status"
  """
  insertJobStatus(
    """the row to be inserted"""
    object: jobStatus_insert_input!

    """on conflict condition"""
    on_conflict: jobStatus_on_conflict
  ): jobStatus

  """
  insert data into the table: "job_status"
  """
  insertJobStatuses(
    """the rows to be inserted"""
    objects: [jobStatus_insert_input!]!

    """on conflict condition"""
    on_conflict: jobStatus_on_conflict
  ): jobStatus_mutation_response

  """
  insert data into the table: "job"
  """
  insertJobs(
    """the rows to be inserted"""
    objects: [job_insert_input!]!

    """on conflict condition"""
    on_conflict: job_on_conflict
  ): job_mutation_response

  """
  insert a single row into the table: "line"
  """
  insertLine(
    """the row to be inserted"""
    object: line_insert_input!

    """on conflict condition"""
    on_conflict: line_on_conflict
  ): line

  """
  insert data into the table: "line"
  """
  insertLines(
    """the rows to be inserted"""
    objects: [line_insert_input!]!

    """on conflict condition"""
    on_conflict: line_on_conflict
  ): line_mutation_response

  """
  insert a single row into the table: "metric"
  """
  insertMetric(
    """the row to be inserted"""
    object: metric_insert_input!

    """on conflict condition"""
    on_conflict: metric_on_conflict
  ): metric

  """
  insert data into the table: "metric"
  """
  insertMetrics(
    """the rows to be inserted"""
    objects: [metric_insert_input!]!

    """on conflict condition"""
    on_conflict: metric_on_conflict
  ): metric_mutation_response

  """
  insert a single row into the table: "normalized_type"
  """
  insertNormalizedType(
    """the row to be inserted"""
    object: normalizedType_insert_input!

    """on conflict condition"""
    on_conflict: normalizedType_on_conflict
  ): normalizedType

  """
  insert data into the table: "normalized_type"
  """
  insertNormalizedTypes(
    """the rows to be inserted"""
    objects: [normalizedType_insert_input!]!

    """on conflict condition"""
    on_conflict: normalizedType_on_conflict
  ): normalizedType_mutation_response

  """
  insert a single row into the table: "payment"
  """
  insertPayment(
    """the row to be inserted"""
    object: payment_insert_input!

    """on conflict condition"""
    on_conflict: payment_on_conflict
  ): payment

  """
  insert a single row into the table: "payment_status"
  """
  insertPaymentStatus(
    """the row to be inserted"""
    object: paymentStatus_insert_input!

    """on conflict condition"""
    on_conflict: paymentStatus_on_conflict
  ): paymentStatus

  """
  insert data into the table: "payment_status"
  """
  insertPaymentStatuses(
    """the rows to be inserted"""
    objects: [paymentStatus_insert_input!]!

    """on conflict condition"""
    on_conflict: paymentStatus_on_conflict
  ): paymentStatus_mutation_response

  """
  insert a single row into the table: "payment_type"
  """
  insertPaymentType(
    """the row to be inserted"""
    object: paymentType_insert_input!

    """on conflict condition"""
    on_conflict: paymentType_on_conflict
  ): paymentType

  """
  insert data into the table: "payment_type"
  """
  insertPaymentTypes(
    """the rows to be inserted"""
    objects: [paymentType_insert_input!]!

    """on conflict condition"""
    on_conflict: paymentType_on_conflict
  ): paymentType_mutation_response

  """
  insert data into the table: "payment"
  """
  insertPayments(
    """the rows to be inserted"""
    objects: [payment_insert_input!]!

    """on conflict condition"""
    on_conflict: payment_on_conflict
  ): payment_mutation_response

  """
  insert a single row into the table: "subclassification"
  """
  insertSubclassification(
    """the row to be inserted"""
    object: subclassification_insert_input!

    """on conflict condition"""
    on_conflict: subclassification_on_conflict
  ): subclassification

  """
  insert data into the table: "subclassification"
  """
  insertSubclassifications(
    """the rows to be inserted"""
    objects: [subclassification_insert_input!]!

    """on conflict condition"""
    on_conflict: subclassification_on_conflict
  ): subclassification_mutation_response

  """
  insert a single row into the table: "tag"
  """
  insertTag(
    """the row to be inserted"""
    object: tag_insert_input!

    """on conflict condition"""
    on_conflict: tag_on_conflict
  ): tag

  """
  insert data into the table: "tag"
  """
  insertTags(
    """the rows to be inserted"""
    objects: [tag_insert_input!]!

    """on conflict condition"""
    on_conflict: tag_on_conflict
  ): tag_mutation_response

  """
  insert a single row into the table: "team"
  """
  insertTeam(
    """the row to be inserted"""
    object: team_insert_input!

    """on conflict condition"""
    on_conflict: team_on_conflict
  ): team

  """
  insert a single row into the table: "team_user"
  """
  insertTeamUser(
    """the row to be inserted"""
    object: teamUser_insert_input!

    """on conflict condition"""
    on_conflict: teamUser_on_conflict
  ): teamUser

  """
  insert data into the table: "team_user"
  """
  insertTeamUsers(
    """the rows to be inserted"""
    objects: [teamUser_insert_input!]!

    """on conflict condition"""
    on_conflict: teamUser_on_conflict
  ): teamUser_mutation_response

  """
  insert data into the table: "team"
  """
  insertTeams(
    """the rows to be inserted"""
    objects: [team_insert_input!]!

    """on conflict condition"""
    on_conflict: team_on_conflict
  ): team_mutation_response

  """
  insert a single row into the table: "unit"
  """
  insertUnit(
    """the row to be inserted"""
    object: unit_insert_input!

    """on conflict condition"""
    on_conflict: unit_on_conflict
  ): unit

  """
  insert data into the table: "unit"
  """
  insertUnits(
    """the rows to be inserted"""
    objects: [unit_insert_input!]!

    """on conflict condition"""
    on_conflict: unit_on_conflict
  ): unit_mutation_response

  """
  insert a single row into the table: "user"
  """
  insertUser(
    """the row to be inserted"""
    object: user_insert_input!

    """on conflict condition"""
    on_conflict: user_on_conflict
  ): user

  """
  insert a single row into the table: "user_status"
  """
  insertUserStatus(
    """the row to be inserted"""
    object: userStatus_insert_input!

    """on conflict condition"""
    on_conflict: userStatus_on_conflict
  ): userStatus

  """
  insert data into the table: "user_status"
  """
  insertUserStatuses(
    """the rows to be inserted"""
    objects: [userStatus_insert_input!]!

    """on conflict condition"""
    on_conflict: userStatus_on_conflict
  ): userStatus_mutation_response

  """
  insert data into the table: "user"
  """
  insertUsers(
    """the rows to be inserted"""
    objects: [user_insert_input!]!

    """on conflict condition"""
    on_conflict: user_on_conflict
  ): user_mutation_response

  """
  insert a single row into the table: "webhook"
  """
  insertWebhook(
    """the row to be inserted"""
    object: webhook_insert_input!

    """on conflict condition"""
    on_conflict: webhook_on_conflict
  ): webhook

  """
  insert data into the table: "webhook"
  """
  insertWebhooks(
    """the rows to be inserted"""
    objects: [webhook_insert_input!]!

    """on conflict condition"""
    on_conflict: webhook_on_conflict
  ): webhook_mutation_response

  """
  insert data into the table: "booking_channel"
  """
  insert_booking_channel(
    """the rows to be inserted"""
    objects: [booking_channel_insert_input!]!

    """on conflict condition"""
    on_conflict: booking_channel_on_conflict
  ): booking_channel_mutation_response

  """
  insert a single row into the table: "booking_channel"
  """
  insert_booking_channel_one(
    """the row to be inserted"""
    object: booking_channel_insert_input!

    """on conflict condition"""
    on_conflict: booking_channel_on_conflict
  ): booking_channel

  """
  update single row of the table: "booking"
  """
  updateBooking(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: booking_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: booking_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: booking_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: booking_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: booking_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: booking_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: booking_set_input
    pk_columns: booking_pk_columns_input!
  ): booking

  """
  update single row of the table: "booking_status"
  """
  updateBookingStatus(
    """sets the columns of the filtered rows to the given values"""
    _set: bookingStatus_set_input
    pk_columns: bookingStatus_pk_columns_input!
  ): bookingStatus

  """
  update data of the table: "booking_status"
  """
  updateBookingStatuses(
    """sets the columns of the filtered rows to the given values"""
    _set: bookingStatus_set_input

    """filter the rows which have to be updated"""
    where: bookingStatus_bool_exp!
  ): bookingStatus_mutation_response

  """
  update data of the table: "booking"
  """
  updateBookings(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: booking_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: booking_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: booking_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: booking_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: booking_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: booking_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: booking_set_input

    """filter the rows which have to be updated"""
    where: booking_bool_exp!
  ): booking_mutation_response

  """
  update single row of the table: "classification"
  """
  updateClassification(
    """sets the columns of the filtered rows to the given values"""
    _set: classification_set_input
    pk_columns: classification_pk_columns_input!
  ): classification

  """
  update data of the table: "classification"
  """
  updateClassifications(
    """sets the columns of the filtered rows to the given values"""
    _set: classification_set_input

    """filter the rows which have to be updated"""
    where: classification_bool_exp!
  ): classification_mutation_response

  """
  update single row of the table: "connection"
  """
  updateConnection(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: connection_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: connection_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: connection_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: connection_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: connection_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: connection_set_input
    pk_columns: connection_pk_columns_input!
  ): connection

  """
  update data of the table: "connection"
  """
  updateConnections(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: connection_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: connection_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: connection_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: connection_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: connection_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: connection_set_input

    """filter the rows which have to be updated"""
    where: connection_bool_exp!
  ): connection_mutation_response

  """
  update data of the table: "currency"
  """
  updateCurrencies(
    """sets the columns of the filtered rows to the given values"""
    _set: currency_set_input

    """filter the rows which have to be updated"""
    where: currency_bool_exp!
  ): currency_mutation_response

  """
  update single row of the table: "currency"
  """
  updateCurrency(
    """sets the columns of the filtered rows to the given values"""
    _set: currency_set_input
    pk_columns: currency_pk_columns_input!
  ): currency

  """
  update data of the table: "entity"
  """
  updateEntities(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: entity_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: entity_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: entity_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: entity_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: entity_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: entity_set_input

    """filter the rows which have to be updated"""
    where: entity_bool_exp!
  ): entity_mutation_response

  """
  update single row of the table: "entity"
  """
  updateEntity(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: entity_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: entity_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: entity_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: entity_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: entity_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: entity_set_input
    pk_columns: entity_pk_columns_input!
  ): entity

  """
  update single row of the table: "entity_status"
  """
  updateEntityStatus(
    """sets the columns of the filtered rows to the given values"""
    _set: entityStatus_set_input
    pk_columns: entityStatus_pk_columns_input!
  ): entityStatus

  """
  update data of the table: "entity_status"
  """
  updateEntityStatuses(
    """sets the columns of the filtered rows to the given values"""
    _set: entityStatus_set_input

    """filter the rows which have to be updated"""
    where: entityStatus_bool_exp!
  ): entityStatus_mutation_response

  """
  update single row of the table: "integration"
  """
  updateIntegration(
    """sets the columns of the filtered rows to the given values"""
    _set: integration_set_input
    pk_columns: integration_pk_columns_input!
  ): integration

  """
  update single row of the table: "integration_type"
  """
  updateIntegrationType(
    """sets the columns of the filtered rows to the given values"""
    _set: integrationType_set_input
    pk_columns: integrationType_pk_columns_input!
  ): integrationType

  """
  update data of the table: "integration_type"
  """
  updateIntegrationTypes(
    """sets the columns of the filtered rows to the given values"""
    _set: integrationType_set_input

    """filter the rows which have to be updated"""
    where: integrationType_bool_exp!
  ): integrationType_mutation_response

  """
  update data of the table: "integration"
  """
  updateIntegrations(
    """sets the columns of the filtered rows to the given values"""
    _set: integration_set_input

    """filter the rows which have to be updated"""
    where: integration_bool_exp!
  ): integration_mutation_response

  """
  update single row of the table: "issue"
  """
  updateIssue(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: issue_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: issue_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: issue_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: issue_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: issue_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: issue_set_input
    pk_columns: issue_pk_columns_input!
  ): issue

  """
  update data of the table: "issue"
  """
  updateIssues(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: issue_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: issue_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: issue_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: issue_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: issue_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: issue_set_input

    """filter the rows which have to be updated"""
    where: issue_bool_exp!
  ): issue_mutation_response

  """
  update single row of the table: "job"
  """
  updateJob(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: job_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: job_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: job_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: job_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: job_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: job_set_input
    pk_columns: job_pk_columns_input!
  ): job

  """
  update single row of the table: "job_method"
  """
  updateJobMethod(
    """sets the columns of the filtered rows to the given values"""
    _set: jobMethod_set_input
    pk_columns: jobMethod_pk_columns_input!
  ): jobMethod

  """
  update data of the table: "job_method"
  """
  updateJobMethods(
    """sets the columns of the filtered rows to the given values"""
    _set: jobMethod_set_input

    """filter the rows which have to be updated"""
    where: jobMethod_bool_exp!
  ): jobMethod_mutation_response

  """
  update single row of the table: "job_status"
  """
  updateJobStatus(
    """sets the columns of the filtered rows to the given values"""
    _set: jobStatus_set_input
    pk_columns: jobStatus_pk_columns_input!
  ): jobStatus

  """
  update data of the table: "job_status"
  """
  updateJobStatuses(
    """sets the columns of the filtered rows to the given values"""
    _set: jobStatus_set_input

    """filter the rows which have to be updated"""
    where: jobStatus_bool_exp!
  ): jobStatus_mutation_response

  """
  update data of the table: "job"
  """
  updateJobs(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: job_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: job_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: job_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: job_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: job_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: job_set_input

    """filter the rows which have to be updated"""
    where: job_bool_exp!
  ): job_mutation_response

  """
  update single row of the table: "line"
  """
  updateLine(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: line_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: line_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: line_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: line_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: line_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: line_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: line_set_input
    pk_columns: line_pk_columns_input!
  ): line

  """
  update data of the table: "line"
  """
  updateLines(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: line_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: line_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: line_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: line_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: line_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: line_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: line_set_input

    """filter the rows which have to be updated"""
    where: line_bool_exp!
  ): line_mutation_response

  """
  update single row of the table: "metric"
  """
  updateMetric(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: metric_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: metric_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: metric_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: metric_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: metric_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: metric_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: metric_set_input
    pk_columns: metric_pk_columns_input!
  ): metric

  """
  update data of the table: "metric"
  """
  updateMetrics(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: metric_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: metric_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: metric_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: metric_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: metric_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: metric_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: metric_set_input

    """filter the rows which have to be updated"""
    where: metric_bool_exp!
  ): metric_mutation_response

  """
  update single row of the table: "normalized_type"
  """
  updateNormalizedType(
    """sets the columns of the filtered rows to the given values"""
    _set: normalizedType_set_input
    pk_columns: normalizedType_pk_columns_input!
  ): normalizedType

  """
  update data of the table: "normalized_type"
  """
  updateNormalizedTypes(
    """sets the columns of the filtered rows to the given values"""
    _set: normalizedType_set_input

    """filter the rows which have to be updated"""
    where: normalizedType_bool_exp!
  ): normalizedType_mutation_response

  """
  update single row of the table: "payment"
  """
  updatePayment(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: payment_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: payment_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: payment_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: payment_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: payment_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: payment_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: payment_set_input
    pk_columns: payment_pk_columns_input!
  ): payment

  """
  update single row of the table: "payment_status"
  """
  updatePaymentStatus(
    """sets the columns of the filtered rows to the given values"""
    _set: paymentStatus_set_input
    pk_columns: paymentStatus_pk_columns_input!
  ): paymentStatus

  """
  update data of the table: "payment_status"
  """
  updatePaymentStatuses(
    """sets the columns of the filtered rows to the given values"""
    _set: paymentStatus_set_input

    """filter the rows which have to be updated"""
    where: paymentStatus_bool_exp!
  ): paymentStatus_mutation_response

  """
  update single row of the table: "payment_type"
  """
  updatePaymentType(
    """sets the columns of the filtered rows to the given values"""
    _set: paymentType_set_input
    pk_columns: paymentType_pk_columns_input!
  ): paymentType

  """
  update data of the table: "payment_type"
  """
  updatePaymentTypes(
    """sets the columns of the filtered rows to the given values"""
    _set: paymentType_set_input

    """filter the rows which have to be updated"""
    where: paymentType_bool_exp!
  ): paymentType_mutation_response

  """
  update data of the table: "payment"
  """
  updatePayments(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: payment_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: payment_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: payment_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: payment_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: payment_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: payment_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: payment_set_input

    """filter the rows which have to be updated"""
    where: payment_bool_exp!
  ): payment_mutation_response

  """
  update single row of the table: "subclassification"
  """
  updateSubclassification(
    """sets the columns of the filtered rows to the given values"""
    _set: subclassification_set_input
    pk_columns: subclassification_pk_columns_input!
  ): subclassification

  """
  update data of the table: "subclassification"
  """
  updateSubclassifications(
    """sets the columns of the filtered rows to the given values"""
    _set: subclassification_set_input

    """filter the rows which have to be updated"""
    where: subclassification_bool_exp!
  ): subclassification_mutation_response

  """
  update single row of the table: "tag"
  """
  updateTag(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: tag_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: tag_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: tag_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: tag_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: tag_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: tag_set_input
    pk_columns: tag_pk_columns_input!
  ): tag

  """
  update data of the table: "tag"
  """
  updateTags(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: tag_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: tag_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: tag_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: tag_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: tag_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: tag_set_input

    """filter the rows which have to be updated"""
    where: tag_bool_exp!
  ): tag_mutation_response

  """
  update single row of the table: "team"
  """
  updateTeam(
    """increments the numeric columns with given value of the filtered values"""
    _inc: team_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: team_set_input
    pk_columns: team_pk_columns_input!
  ): team

  """
  update single row of the table: "team_user"
  """
  updateTeamUser(
    """sets the columns of the filtered rows to the given values"""
    _set: teamUser_set_input
    pk_columns: teamUser_pk_columns_input!
  ): teamUser

  """
  update data of the table: "team_user"
  """
  updateTeamUsers(
    """sets the columns of the filtered rows to the given values"""
    _set: teamUser_set_input

    """filter the rows which have to be updated"""
    where: teamUser_bool_exp!
  ): teamUser_mutation_response

  """
  update data of the table: "team"
  """
  updateTeams(
    """increments the numeric columns with given value of the filtered values"""
    _inc: team_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: team_set_input

    """filter the rows which have to be updated"""
    where: team_bool_exp!
  ): team_mutation_response

  """
  update single row of the table: "unit"
  """
  updateUnit(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: unit_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: unit_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: unit_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: unit_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: unit_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: unit_set_input
    pk_columns: unit_pk_columns_input!
  ): unit

  """
  update data of the table: "unit"
  """
  updateUnits(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: unit_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: unit_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: unit_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: unit_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: unit_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: unit_set_input

    """filter the rows which have to be updated"""
    where: unit_bool_exp!
  ): unit_mutation_response

  """
  update single row of the table: "user"
  """
  updateUser(
    """sets the columns of the filtered rows to the given values"""
    _set: user_set_input
    pk_columns: user_pk_columns_input!
  ): user

  """
  update single row of the table: "user_status"
  """
  updateUserStatus(
    """sets the columns of the filtered rows to the given values"""
    _set: userStatus_set_input
    pk_columns: userStatus_pk_columns_input!
  ): userStatus

  """
  update data of the table: "user_status"
  """
  updateUserStatuses(
    """sets the columns of the filtered rows to the given values"""
    _set: userStatus_set_input

    """filter the rows which have to be updated"""
    where: userStatus_bool_exp!
  ): userStatus_mutation_response

  """
  update data of the table: "user"
  """
  updateUsers(
    """sets the columns of the filtered rows to the given values"""
    _set: user_set_input

    """filter the rows which have to be updated"""
    where: user_bool_exp!
  ): user_mutation_response

  """
  update single row of the table: "webhook"
  """
  updateWebhook(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: webhook_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: webhook_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: webhook_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: webhook_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: webhook_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: webhook_set_input
    pk_columns: webhook_pk_columns_input!
  ): webhook

  """
  update data of the table: "webhook"
  """
  updateWebhooks(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: webhook_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: webhook_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: webhook_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: webhook_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: webhook_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: webhook_set_input

    """filter the rows which have to be updated"""
    where: webhook_bool_exp!
  ): webhook_mutation_response

  """
  update data of the table: "booking_channel"
  """
  update_booking_channel(
    """sets the columns of the filtered rows to the given values"""
    _set: booking_channel_set_input

    """filter the rows which have to be updated"""
    where: booking_channel_bool_exp!
  ): booking_channel_mutation_response

  """
  update single row of the table: "booking_channel"
  """
  update_booking_channel_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: booking_channel_set_input
    pk_columns: booking_channel_pk_columns_input!
  ): booking_channel
}

enum normalized_type_enum {
  booking
  line
  metric
  payment
  tag
  unit
}

"""
Boolean expression to compare columns of type "normalized_type_enum". All fields are combined with logical 'AND'.
"""
input normalized_type_enum_comparison_exp {
  _eq: normalized_type_enum
  _in: [normalized_type_enum!]
  _is_null: Boolean
  _neq: normalized_type_enum
  _nin: [normalized_type_enum!]
}

"""
columns and relationships of "normalized_type"
"""
type normalizedType {
  name: String!
}

"""
aggregated selection of "normalized_type"
"""
type normalizedType_aggregate {
  aggregate: normalizedType_aggregate_fields
  nodes: [normalizedType!]!
}

"""
aggregate fields of "normalized_type"
"""
type normalizedType_aggregate_fields {
  count(columns: [normalizedType_select_column!], distinct: Boolean): Int!
  max: normalizedType_max_fields
  min: normalizedType_min_fields
}

"""
Boolean expression to filter rows from the table "normalized_type". All fields are combined with a logical 'AND'.
"""
input normalizedType_bool_exp {
  _and: [normalizedType_bool_exp!]
  _not: normalizedType_bool_exp
  _or: [normalizedType_bool_exp!]
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "normalized_type"
"""
enum normalizedType_constraint {
  """unique or primary key constraint"""
  normalized_type_pkey
}

"""
input type for inserting data into table "normalized_type"
"""
input normalizedType_insert_input {
  name: String
}

"""aggregate max on columns"""
type normalizedType_max_fields {
  name: String
}

"""aggregate min on columns"""
type normalizedType_min_fields {
  name: String
}

"""
response of any mutation on the table "normalized_type"
"""
type normalizedType_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [normalizedType!]!
}

"""
on conflict condition type for table "normalized_type"
"""
input normalizedType_on_conflict {
  constraint: normalizedType_constraint!
  update_columns: [normalizedType_update_column!]! = []
  where: normalizedType_bool_exp
}

"""Ordering options when selecting data from "normalized_type"."""
input normalizedType_order_by {
  name: order_by
}

"""primary key columns input for table: normalizedType"""
input normalizedType_pk_columns_input {
  name: String!
}

"""
select columns of table "normalized_type"
"""
enum normalizedType_select_column {
  """column name"""
  name
}

"""
input type for updating data in table "normalized_type"
"""
input normalizedType_set_input {
  name: String
}

"""
update columns of table "normalized_type"
"""
enum normalizedType_update_column {
  """column name"""
  name
}

scalar numeric

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

"""
columns and relationships of "payment"
"""
type payment {
  arrivesAt: timestamptz
  centTotal: Int

  """An object relationship"""
  connection: connection
  connectionId: uuid
  createdAt: timestamptz
  currency: currency_enum
  description: String

  """An object relationship"""
  entity: entity
  entityId: uuid
  id: uuid!

  """An array relationship"""
  lines(
    """distinct select on columns"""
    distinct_on: [line_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [line_order_by!]

    """filter the rows returned"""
    where: line_bool_exp
  ): [line!]!

  """An aggregate relationship"""
  lines_aggregate(
    """distinct select on columns"""
    distinct_on: [line_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [line_order_by!]

    """filter the rows returned"""
    where: line_bool_exp
  ): line_aggregate!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  paidAt: timestamptz
  status: payment_status_enum

  """An array relationship"""
  tags(
    """distinct select on columns"""
    distinct_on: [tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tag_order_by!]

    """filter the rows returned"""
    where: tag_bool_exp
  ): [tag!]!

  """An aggregate relationship"""
  tags_aggregate(
    """distinct select on columns"""
    distinct_on: [tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tag_order_by!]

    """filter the rows returned"""
    where: tag_bool_exp
  ): tag_aggregate!

  """An object relationship"""
  team: team
  teamId: uuid
  type: String
  uniqueRef: String
  updatedAt: timestamptz
}

"""
aggregated selection of "payment"
"""
type payment_aggregate {
  aggregate: payment_aggregate_fields
  nodes: [payment!]!
}

"""
aggregate fields of "payment"
"""
type payment_aggregate_fields {
  avg: payment_avg_fields
  count(columns: [payment_select_column!], distinct: Boolean): Int!
  max: payment_max_fields
  min: payment_min_fields
  stddev: payment_stddev_fields
  stddev_pop: payment_stddev_pop_fields
  stddev_samp: payment_stddev_samp_fields
  sum: payment_sum_fields
  var_pop: payment_var_pop_fields
  var_samp: payment_var_samp_fields
  variance: payment_variance_fields
}

"""
order by aggregate values of table "payment"
"""
input payment_aggregate_order_by {
  avg: payment_avg_order_by
  count: order_by
  max: payment_max_order_by
  min: payment_min_order_by
  stddev: payment_stddev_order_by
  stddev_pop: payment_stddev_pop_order_by
  stddev_samp: payment_stddev_samp_order_by
  sum: payment_sum_order_by
  var_pop: payment_var_pop_order_by
  var_samp: payment_var_samp_order_by
  variance: payment_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input payment_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "payment"
"""
input payment_arr_rel_insert_input {
  data: [payment_insert_input!]!

  """on conflict condition"""
  on_conflict: payment_on_conflict
}

"""aggregate avg on columns"""
type payment_avg_fields {
  centTotal: Float
}

"""
order by avg() on columns of table "payment"
"""
input payment_avg_order_by {
  centTotal: order_by
}

"""
Boolean expression to filter rows from the table "payment". All fields are combined with a logical 'AND'.
"""
input payment_bool_exp {
  _and: [payment_bool_exp!]
  _not: payment_bool_exp
  _or: [payment_bool_exp!]
  arrivesAt: timestamptz_comparison_exp
  centTotal: Int_comparison_exp
  connection: connection_bool_exp
  connectionId: uuid_comparison_exp
  createdAt: timestamptz_comparison_exp
  currency: currency_enum_comparison_exp
  description: String_comparison_exp
  entity: entity_bool_exp
  entityId: uuid_comparison_exp
  id: uuid_comparison_exp
  lines: line_bool_exp
  metadata: jsonb_comparison_exp
  paidAt: timestamptz_comparison_exp
  status: payment_status_enum_comparison_exp
  tags: tag_bool_exp
  team: team_bool_exp
  teamId: uuid_comparison_exp
  type: String_comparison_exp
  uniqueRef: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "payment"
"""
enum payment_constraint {
  """unique or primary key constraint"""
  payment_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input payment_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input payment_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input payment_delete_key_input {
  metadata: String
}

"""
input type for incrementing numeric columns in table "payment"
"""
input payment_inc_input {
  centTotal: Int
}

"""
input type for inserting data into table "payment"
"""
input payment_insert_input {
  arrivesAt: timestamptz
  centTotal: Int
  connection: connection_obj_rel_insert_input
  connectionId: uuid
  createdAt: timestamptz
  currency: currency_enum
  description: String
  entity: entity_obj_rel_insert_input
  entityId: uuid
  id: uuid
  lines: line_arr_rel_insert_input
  metadata: jsonb
  paidAt: timestamptz
  status: payment_status_enum
  tags: tag_arr_rel_insert_input
  team: team_obj_rel_insert_input
  teamId: uuid
  type: String
  uniqueRef: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type payment_max_fields {
  arrivesAt: timestamptz
  centTotal: Int
  connectionId: uuid
  createdAt: timestamptz
  description: String
  entityId: uuid
  id: uuid
  paidAt: timestamptz
  teamId: uuid
  type: String
  uniqueRef: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "payment"
"""
input payment_max_order_by {
  arrivesAt: order_by
  centTotal: order_by
  connectionId: order_by
  createdAt: order_by
  description: order_by
  entityId: order_by
  id: order_by
  paidAt: order_by
  teamId: order_by
  type: order_by
  uniqueRef: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type payment_min_fields {
  arrivesAt: timestamptz
  centTotal: Int
  connectionId: uuid
  createdAt: timestamptz
  description: String
  entityId: uuid
  id: uuid
  paidAt: timestamptz
  teamId: uuid
  type: String
  uniqueRef: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "payment"
"""
input payment_min_order_by {
  arrivesAt: order_by
  centTotal: order_by
  connectionId: order_by
  createdAt: order_by
  description: order_by
  entityId: order_by
  id: order_by
  paidAt: order_by
  teamId: order_by
  type: order_by
  uniqueRef: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "payment"
"""
type payment_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [payment!]!
}

"""
input type for inserting object relation for remote table "payment"
"""
input payment_obj_rel_insert_input {
  data: payment_insert_input!

  """on conflict condition"""
  on_conflict: payment_on_conflict
}

"""
on conflict condition type for table "payment"
"""
input payment_on_conflict {
  constraint: payment_constraint!
  update_columns: [payment_update_column!]! = []
  where: payment_bool_exp
}

"""Ordering options when selecting data from "payment"."""
input payment_order_by {
  arrivesAt: order_by
  centTotal: order_by
  connection: connection_order_by
  connectionId: order_by
  createdAt: order_by
  currency: order_by
  description: order_by
  entity: entity_order_by
  entityId: order_by
  id: order_by
  lines_aggregate: line_aggregate_order_by
  metadata: order_by
  paidAt: order_by
  status: order_by
  tags_aggregate: tag_aggregate_order_by
  team: team_order_by
  teamId: order_by
  type: order_by
  uniqueRef: order_by
  updatedAt: order_by
}

"""primary key columns input for table: payment"""
input payment_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input payment_prepend_input {
  metadata: jsonb
}

"""
select columns of table "payment"
"""
enum payment_select_column {
  """column name"""
  arrivesAt

  """column name"""
  centTotal

  """column name"""
  connectionId

  """column name"""
  createdAt

  """column name"""
  currency

  """column name"""
  description

  """column name"""
  entityId

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  paidAt

  """column name"""
  status

  """column name"""
  teamId

  """column name"""
  type

  """column name"""
  uniqueRef

  """column name"""
  updatedAt
}

"""
input type for updating data in table "payment"
"""
input payment_set_input {
  arrivesAt: timestamptz
  centTotal: Int
  connectionId: uuid
  createdAt: timestamptz
  currency: currency_enum
  description: String
  entityId: uuid
  id: uuid
  metadata: jsonb
  paidAt: timestamptz
  status: payment_status_enum
  teamId: uuid
  type: String
  uniqueRef: String
  updatedAt: timestamptz
}

enum payment_status_enum {
  arrived
  cancelled
  pending
}

"""
Boolean expression to compare columns of type "payment_status_enum". All fields are combined with logical 'AND'.
"""
input payment_status_enum_comparison_exp {
  _eq: payment_status_enum
  _in: [payment_status_enum!]
  _is_null: Boolean
  _neq: payment_status_enum
  _nin: [payment_status_enum!]
}

"""aggregate stddev on columns"""
type payment_stddev_fields {
  centTotal: Float
}

"""
order by stddev() on columns of table "payment"
"""
input payment_stddev_order_by {
  centTotal: order_by
}

"""aggregate stddev_pop on columns"""
type payment_stddev_pop_fields {
  centTotal: Float
}

"""
order by stddev_pop() on columns of table "payment"
"""
input payment_stddev_pop_order_by {
  centTotal: order_by
}

"""aggregate stddev_samp on columns"""
type payment_stddev_samp_fields {
  centTotal: Float
}

"""
order by stddev_samp() on columns of table "payment"
"""
input payment_stddev_samp_order_by {
  centTotal: order_by
}

"""aggregate sum on columns"""
type payment_sum_fields {
  centTotal: Int
}

"""
order by sum() on columns of table "payment"
"""
input payment_sum_order_by {
  centTotal: order_by
}

"""
update columns of table "payment"
"""
enum payment_update_column {
  """column name"""
  arrivesAt

  """column name"""
  centTotal

  """column name"""
  connectionId

  """column name"""
  createdAt

  """column name"""
  currency

  """column name"""
  description

  """column name"""
  entityId

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  paidAt

  """column name"""
  status

  """column name"""
  teamId

  """column name"""
  type

  """column name"""
  uniqueRef

  """column name"""
  updatedAt
}

"""aggregate var_pop on columns"""
type payment_var_pop_fields {
  centTotal: Float
}

"""
order by var_pop() on columns of table "payment"
"""
input payment_var_pop_order_by {
  centTotal: order_by
}

"""aggregate var_samp on columns"""
type payment_var_samp_fields {
  centTotal: Float
}

"""
order by var_samp() on columns of table "payment"
"""
input payment_var_samp_order_by {
  centTotal: order_by
}

"""aggregate variance on columns"""
type payment_variance_fields {
  centTotal: Float
}

"""
order by variance() on columns of table "payment"
"""
input payment_variance_order_by {
  centTotal: order_by
}

"""
columns and relationships of "payment_status"
"""
type paymentStatus {
  name: String!
}

"""
aggregated selection of "payment_status"
"""
type paymentStatus_aggregate {
  aggregate: paymentStatus_aggregate_fields
  nodes: [paymentStatus!]!
}

"""
aggregate fields of "payment_status"
"""
type paymentStatus_aggregate_fields {
  count(columns: [paymentStatus_select_column!], distinct: Boolean): Int!
  max: paymentStatus_max_fields
  min: paymentStatus_min_fields
}

"""
Boolean expression to filter rows from the table "payment_status". All fields are combined with a logical 'AND'.
"""
input paymentStatus_bool_exp {
  _and: [paymentStatus_bool_exp!]
  _not: paymentStatus_bool_exp
  _or: [paymentStatus_bool_exp!]
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "payment_status"
"""
enum paymentStatus_constraint {
  """unique or primary key constraint"""
  payment_status_pkey
}

"""
input type for inserting data into table "payment_status"
"""
input paymentStatus_insert_input {
  name: String
}

"""aggregate max on columns"""
type paymentStatus_max_fields {
  name: String
}

"""aggregate min on columns"""
type paymentStatus_min_fields {
  name: String
}

"""
response of any mutation on the table "payment_status"
"""
type paymentStatus_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [paymentStatus!]!
}

"""
on conflict condition type for table "payment_status"
"""
input paymentStatus_on_conflict {
  constraint: paymentStatus_constraint!
  update_columns: [paymentStatus_update_column!]! = []
  where: paymentStatus_bool_exp
}

"""Ordering options when selecting data from "payment_status"."""
input paymentStatus_order_by {
  name: order_by
}

"""primary key columns input for table: paymentStatus"""
input paymentStatus_pk_columns_input {
  name: String!
}

"""
select columns of table "payment_status"
"""
enum paymentStatus_select_column {
  """column name"""
  name
}

"""
input type for updating data in table "payment_status"
"""
input paymentStatus_set_input {
  name: String
}

"""
update columns of table "payment_status"
"""
enum paymentStatus_update_column {
  """column name"""
  name
}

"""
columns and relationships of "payment_type"
"""
type paymentType {
  name: String!
}

"""
aggregated selection of "payment_type"
"""
type paymentType_aggregate {
  aggregate: paymentType_aggregate_fields
  nodes: [paymentType!]!
}

"""
aggregate fields of "payment_type"
"""
type paymentType_aggregate_fields {
  count(columns: [paymentType_select_column!], distinct: Boolean): Int!
  max: paymentType_max_fields
  min: paymentType_min_fields
}

"""
Boolean expression to filter rows from the table "payment_type". All fields are combined with a logical 'AND'.
"""
input paymentType_bool_exp {
  _and: [paymentType_bool_exp!]
  _not: paymentType_bool_exp
  _or: [paymentType_bool_exp!]
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "payment_type"
"""
enum paymentType_constraint {
  """unique or primary key constraint"""
  payment_type_pkey
}

"""
input type for inserting data into table "payment_type"
"""
input paymentType_insert_input {
  name: String
}

"""aggregate max on columns"""
type paymentType_max_fields {
  name: String
}

"""aggregate min on columns"""
type paymentType_min_fields {
  name: String
}

"""
response of any mutation on the table "payment_type"
"""
type paymentType_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [paymentType!]!
}

"""
on conflict condition type for table "payment_type"
"""
input paymentType_on_conflict {
  constraint: paymentType_constraint!
  update_columns: [paymentType_update_column!]! = []
  where: paymentType_bool_exp
}

"""Ordering options when selecting data from "payment_type"."""
input paymentType_order_by {
  name: order_by
}

"""primary key columns input for table: paymentType"""
input paymentType_pk_columns_input {
  name: String!
}

"""
select columns of table "payment_type"
"""
enum paymentType_select_column {
  """column name"""
  name
}

"""
input type for updating data in table "payment_type"
"""
input paymentType_set_input {
  name: String
}

"""
update columns of table "payment_type"
"""
enum paymentType_update_column {
  """column name"""
  name
}

type query_root {
  """
  fetch aggregated fields from the table: "booking_status"
  """
  aggregateBookingStatuses(
    """distinct select on columns"""
    distinct_on: [bookingStatus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bookingStatus_order_by!]

    """filter the rows returned"""
    where: bookingStatus_bool_exp
  ): bookingStatus_aggregate!

  """
  fetch aggregated fields from the table: "booking"
  """
  aggregateBookings(
    """distinct select on columns"""
    distinct_on: [booking_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_order_by!]

    """filter the rows returned"""
    where: booking_bool_exp
  ): booking_aggregate!

  """
  fetch aggregated fields from the table: "classification"
  """
  aggregateClassifications(
    """distinct select on columns"""
    distinct_on: [classification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [classification_order_by!]

    """filter the rows returned"""
    where: classification_bool_exp
  ): classification_aggregate!

  """
  fetch aggregated fields from the table: "connection"
  """
  aggregateConnections(
    """distinct select on columns"""
    distinct_on: [connection_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [connection_order_by!]

    """filter the rows returned"""
    where: connection_bool_exp
  ): connection_aggregate!

  """
  fetch aggregated fields from the table: "currency"
  """
  aggregateCurrencies(
    """distinct select on columns"""
    distinct_on: [currency_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [currency_order_by!]

    """filter the rows returned"""
    where: currency_bool_exp
  ): currency_aggregate!

  """
  fetch aggregated fields from the table: "entity"
  """
  aggregateEntities(
    """distinct select on columns"""
    distinct_on: [entity_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [entity_order_by!]

    """filter the rows returned"""
    where: entity_bool_exp
  ): entity_aggregate!

  """
  fetch aggregated fields from the table: "entity_status"
  """
  aggregateEntityStatuses(
    """distinct select on columns"""
    distinct_on: [entityStatus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [entityStatus_order_by!]

    """filter the rows returned"""
    where: entityStatus_bool_exp
  ): entityStatus_aggregate!

  """
  fetch aggregated fields from the table: "integration_type"
  """
  aggregateIntegrationTypes(
    """distinct select on columns"""
    distinct_on: [integrationType_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationType_order_by!]

    """filter the rows returned"""
    where: integrationType_bool_exp
  ): integrationType_aggregate!

  """
  fetch aggregated fields from the table: "integration"
  """
  aggregateIntegrations(
    """distinct select on columns"""
    distinct_on: [integration_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integration_order_by!]

    """filter the rows returned"""
    where: integration_bool_exp
  ): integration_aggregate!

  """
  fetch aggregated fields from the table: "issue"
  """
  aggregateIssues(
    """distinct select on columns"""
    distinct_on: [issue_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [issue_order_by!]

    """filter the rows returned"""
    where: issue_bool_exp
  ): issue_aggregate!

  """
  fetch aggregated fields from the table: "job_method"
  """
  aggregateJobMethods(
    """distinct select on columns"""
    distinct_on: [jobMethod_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [jobMethod_order_by!]

    """filter the rows returned"""
    where: jobMethod_bool_exp
  ): jobMethod_aggregate!

  """
  fetch aggregated fields from the table: "job_status"
  """
  aggregateJobStatuses(
    """distinct select on columns"""
    distinct_on: [jobStatus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [jobStatus_order_by!]

    """filter the rows returned"""
    where: jobStatus_bool_exp
  ): jobStatus_aggregate!

  """
  fetch aggregated fields from the table: "job"
  """
  aggregateJobs(
    """distinct select on columns"""
    distinct_on: [job_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [job_order_by!]

    """filter the rows returned"""
    where: job_bool_exp
  ): job_aggregate!

  """
  fetch aggregated fields from the table: "line"
  """
  aggregateLines(
    """distinct select on columns"""
    distinct_on: [line_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [line_order_by!]

    """filter the rows returned"""
    where: line_bool_exp
  ): line_aggregate!

  """
  fetch aggregated fields from the table: "metric"
  """
  aggregateMetrics(
    """distinct select on columns"""
    distinct_on: [metric_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [metric_order_by!]

    """filter the rows returned"""
    where: metric_bool_exp
  ): metric_aggregate!

  """
  fetch aggregated fields from the table: "normalized_type"
  """
  aggregateNormalizedTypes(
    """distinct select on columns"""
    distinct_on: [normalizedType_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [normalizedType_order_by!]

    """filter the rows returned"""
    where: normalizedType_bool_exp
  ): normalizedType_aggregate!

  """
  fetch aggregated fields from the table: "payment_status"
  """
  aggregatePaymentStatuses(
    """distinct select on columns"""
    distinct_on: [paymentStatus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [paymentStatus_order_by!]

    """filter the rows returned"""
    where: paymentStatus_bool_exp
  ): paymentStatus_aggregate!

  """
  fetch aggregated fields from the table: "payment_type"
  """
  aggregatePaymentTypes(
    """distinct select on columns"""
    distinct_on: [paymentType_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [paymentType_order_by!]

    """filter the rows returned"""
    where: paymentType_bool_exp
  ): paymentType_aggregate!

  """
  fetch aggregated fields from the table: "payment"
  """
  aggregatePayments(
    """distinct select on columns"""
    distinct_on: [payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_order_by!]

    """filter the rows returned"""
    where: payment_bool_exp
  ): payment_aggregate!

  """
  fetch aggregated fields from the table: "subclassification"
  """
  aggregateSubclassifications(
    """distinct select on columns"""
    distinct_on: [subclassification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subclassification_order_by!]

    """filter the rows returned"""
    where: subclassification_bool_exp
  ): subclassification_aggregate!

  """
  fetch aggregated fields from the table: "tag"
  """
  aggregateTags(
    """distinct select on columns"""
    distinct_on: [tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tag_order_by!]

    """filter the rows returned"""
    where: tag_bool_exp
  ): tag_aggregate!

  """
  fetch aggregated fields from the table: "team_user"
  """
  aggregateTeamUsers(
    """distinct select on columns"""
    distinct_on: [teamUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamUser_order_by!]

    """filter the rows returned"""
    where: teamUser_bool_exp
  ): teamUser_aggregate!

  """
  fetch aggregated fields from the table: "team"
  """
  aggregateTeams(
    """distinct select on columns"""
    distinct_on: [team_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [team_order_by!]

    """filter the rows returned"""
    where: team_bool_exp
  ): team_aggregate!

  """
  fetch aggregated fields from the table: "unit"
  """
  aggregateUnits(
    """distinct select on columns"""
    distinct_on: [unit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [unit_order_by!]

    """filter the rows returned"""
    where: unit_bool_exp
  ): unit_aggregate!

  """
  fetch aggregated fields from the table: "user_status"
  """
  aggregateUserStatuses(
    """distinct select on columns"""
    distinct_on: [userStatus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userStatus_order_by!]

    """filter the rows returned"""
    where: userStatus_bool_exp
  ): userStatus_aggregate!

  """
  fetch aggregated fields from the table: "user"
  """
  aggregateUsers(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): user_aggregate!

  """
  fetch aggregated fields from the table: "webhook"
  """
  aggregateWebhooks(
    """distinct select on columns"""
    distinct_on: [webhook_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [webhook_order_by!]

    """filter the rows returned"""
    where: webhook_bool_exp
  ): webhook_aggregate!

  """fetch data from the table: "booking" using primary key columns"""
  booking(id: uuid!): booking

  """fetch data from the table: "booking_status" using primary key columns"""
  bookingStatus(name: String!): bookingStatus

  """
  fetch data from the table: "booking_status"
  """
  bookingStatuses(
    """distinct select on columns"""
    distinct_on: [bookingStatus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bookingStatus_order_by!]

    """filter the rows returned"""
    where: bookingStatus_bool_exp
  ): [bookingStatus!]!

  """
  fetch data from the table: "booking_channel"
  """
  booking_channel(
    """distinct select on columns"""
    distinct_on: [booking_channel_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_channel_order_by!]

    """filter the rows returned"""
    where: booking_channel_bool_exp
  ): [booking_channel!]!

  """
  fetch aggregated fields from the table: "booking_channel"
  """
  booking_channel_aggregate(
    """distinct select on columns"""
    distinct_on: [booking_channel_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_channel_order_by!]

    """filter the rows returned"""
    where: booking_channel_bool_exp
  ): booking_channel_aggregate!

  """fetch data from the table: "booking_channel" using primary key columns"""
  booking_channel_by_pk(name: String!): booking_channel

  """An array relationship"""
  bookings(
    """distinct select on columns"""
    distinct_on: [booking_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_order_by!]

    """filter the rows returned"""
    where: booking_bool_exp
  ): [booking!]!

  """fetch data from the table: "classification" using primary key columns"""
  classification(name: String!): classification

  """
  fetch data from the table: "classification"
  """
  classifications(
    """distinct select on columns"""
    distinct_on: [classification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [classification_order_by!]

    """filter the rows returned"""
    where: classification_bool_exp
  ): [classification!]!

  """fetch data from the table: "connection" using primary key columns"""
  connection(id: uuid!): connection

  """An array relationship"""
  connections(
    """distinct select on columns"""
    distinct_on: [connection_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [connection_order_by!]

    """filter the rows returned"""
    where: connection_bool_exp
  ): [connection!]!

  """
  fetch data from the table: "currency"
  """
  currencies(
    """distinct select on columns"""
    distinct_on: [currency_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [currency_order_by!]

    """filter the rows returned"""
    where: currency_bool_exp
  ): [currency!]!

  """fetch data from the table: "currency" using primary key columns"""
  currency(name: String!): currency

  """An array relationship"""
  entities(
    """distinct select on columns"""
    distinct_on: [entity_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [entity_order_by!]

    """filter the rows returned"""
    where: entity_bool_exp
  ): [entity!]!

  """fetch data from the table: "entity" using primary key columns"""
  entity(id: uuid!): entity

  """fetch data from the table: "entity_status" using primary key columns"""
  entityStatus(name: String!): entityStatus

  """
  fetch data from the table: "entity_status"
  """
  entityStatuses(
    """distinct select on columns"""
    distinct_on: [entityStatus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [entityStatus_order_by!]

    """filter the rows returned"""
    where: entityStatus_bool_exp
  ): [entityStatus!]!

  """fetch data from the table: "integration" using primary key columns"""
  integration(id: uuid!): integration

  """
  fetch data from the table: "integration_type" using primary key columns
  """
  integrationType(name: String!): integrationType

  """
  fetch data from the table: "integration_type"
  """
  integrationTypes(
    """distinct select on columns"""
    distinct_on: [integrationType_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationType_order_by!]

    """filter the rows returned"""
    where: integrationType_bool_exp
  ): [integrationType!]!

  """An array relationship"""
  integrations(
    """distinct select on columns"""
    distinct_on: [integration_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integration_order_by!]

    """filter the rows returned"""
    where: integration_bool_exp
  ): [integration!]!

  """fetch data from the table: "issue" using primary key columns"""
  issue(id: uuid!): issue

  """An array relationship"""
  issues(
    """distinct select on columns"""
    distinct_on: [issue_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [issue_order_by!]

    """filter the rows returned"""
    where: issue_bool_exp
  ): [issue!]!

  """fetch data from the table: "job" using primary key columns"""
  job(id: uuid!): job

  """fetch data from the table: "job_method" using primary key columns"""
  jobMethod(name: String!): jobMethod

  """
  fetch data from the table: "job_method"
  """
  jobMethods(
    """distinct select on columns"""
    distinct_on: [jobMethod_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [jobMethod_order_by!]

    """filter the rows returned"""
    where: jobMethod_bool_exp
  ): [jobMethod!]!

  """fetch data from the table: "job_status" using primary key columns"""
  jobStatus(name: String!): jobStatus

  """
  fetch data from the table: "job_status"
  """
  jobStatuses(
    """distinct select on columns"""
    distinct_on: [jobStatus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [jobStatus_order_by!]

    """filter the rows returned"""
    where: jobStatus_bool_exp
  ): [jobStatus!]!

  """An array relationship"""
  jobs(
    """distinct select on columns"""
    distinct_on: [job_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [job_order_by!]

    """filter the rows returned"""
    where: job_bool_exp
  ): [job!]!

  """fetch data from the table: "line" using primary key columns"""
  line(id: uuid!): line

  """An array relationship"""
  lines(
    """distinct select on columns"""
    distinct_on: [line_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [line_order_by!]

    """filter the rows returned"""
    where: line_bool_exp
  ): [line!]!

  """fetch data from the table: "metric" using primary key columns"""
  metric(id: uuid!): metric

  """An array relationship"""
  metrics(
    """distinct select on columns"""
    distinct_on: [metric_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [metric_order_by!]

    """filter the rows returned"""
    where: metric_bool_exp
  ): [metric!]!

  """fetch data from the table: "normalized_type" using primary key columns"""
  normalizedType(name: String!): normalizedType

  """
  fetch data from the table: "normalized_type"
  """
  normalizedTypes(
    """distinct select on columns"""
    distinct_on: [normalizedType_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [normalizedType_order_by!]

    """filter the rows returned"""
    where: normalizedType_bool_exp
  ): [normalizedType!]!

  """fetch data from the table: "payment" using primary key columns"""
  payment(id: uuid!): payment

  """fetch data from the table: "payment_status" using primary key columns"""
  paymentStatus(name: String!): paymentStatus

  """
  fetch data from the table: "payment_status"
  """
  paymentStatuses(
    """distinct select on columns"""
    distinct_on: [paymentStatus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [paymentStatus_order_by!]

    """filter the rows returned"""
    where: paymentStatus_bool_exp
  ): [paymentStatus!]!

  """fetch data from the table: "payment_type" using primary key columns"""
  paymentType(name: String!): paymentType

  """
  fetch data from the table: "payment_type"
  """
  paymentTypes(
    """distinct select on columns"""
    distinct_on: [paymentType_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [paymentType_order_by!]

    """filter the rows returned"""
    where: paymentType_bool_exp
  ): [paymentType!]!

  """An array relationship"""
  payments(
    """distinct select on columns"""
    distinct_on: [payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_order_by!]

    """filter the rows returned"""
    where: payment_bool_exp
  ): [payment!]!

  """
  fetch data from the table: "subclassification" using primary key columns
  """
  subclassification(name: String!): subclassification

  """
  fetch data from the table: "subclassification"
  """
  subclassifications(
    """distinct select on columns"""
    distinct_on: [subclassification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subclassification_order_by!]

    """filter the rows returned"""
    where: subclassification_bool_exp
  ): [subclassification!]!

  """fetch data from the table: "tag" using primary key columns"""
  tag(id: uuid!): tag

  """An array relationship"""
  tags(
    """distinct select on columns"""
    distinct_on: [tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tag_order_by!]

    """filter the rows returned"""
    where: tag_bool_exp
  ): [tag!]!

  """fetch data from the table: "team" using primary key columns"""
  team(id: uuid!): team

  """fetch data from the table: "team_user" using primary key columns"""
  teamUser(id: uuid!): teamUser

  """
  fetch data from the table: "team_user"
  """
  teamUsers(
    """distinct select on columns"""
    distinct_on: [teamUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamUser_order_by!]

    """filter the rows returned"""
    where: teamUser_bool_exp
  ): [teamUser!]!

  """
  fetch data from the table: "team"
  """
  teams(
    """distinct select on columns"""
    distinct_on: [team_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [team_order_by!]

    """filter the rows returned"""
    where: team_bool_exp
  ): [team!]!

  """fetch data from the table: "unit" using primary key columns"""
  unit(id: uuid!): unit

  """An array relationship"""
  units(
    """distinct select on columns"""
    distinct_on: [unit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [unit_order_by!]

    """filter the rows returned"""
    where: unit_bool_exp
  ): [unit!]!

  """fetch data from the table: "user" using primary key columns"""
  user(id: uuid!): user

  """fetch data from the table: "user_status" using primary key columns"""
  userStatus(name: String!): userStatus

  """
  fetch data from the table: "user_status"
  """
  userStatuses(
    """distinct select on columns"""
    distinct_on: [userStatus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userStatus_order_by!]

    """filter the rows returned"""
    where: userStatus_bool_exp
  ): [userStatus!]!

  """
  fetch data from the table: "user"
  """
  users(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """fetch data from the table: "webhook" using primary key columns"""
  webhook(id: uuid!): webhook

  """An array relationship"""
  webhooks(
    """distinct select on columns"""
    distinct_on: [webhook_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [webhook_order_by!]

    """filter the rows returned"""
    where: webhook_bool_exp
  ): [webhook!]!
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""
columns and relationships of "subclassification"
"""
type subclassification {
  name: String!
}

"""
aggregated selection of "subclassification"
"""
type subclassification_aggregate {
  aggregate: subclassification_aggregate_fields
  nodes: [subclassification!]!
}

"""
aggregate fields of "subclassification"
"""
type subclassification_aggregate_fields {
  count(columns: [subclassification_select_column!], distinct: Boolean): Int!
  max: subclassification_max_fields
  min: subclassification_min_fields
}

"""
Boolean expression to filter rows from the table "subclassification". All fields are combined with a logical 'AND'.
"""
input subclassification_bool_exp {
  _and: [subclassification_bool_exp!]
  _not: subclassification_bool_exp
  _or: [subclassification_bool_exp!]
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "subclassification"
"""
enum subclassification_constraint {
  """unique or primary key constraint"""
  subclassification_pkey
}

enum subclassification_enum {
  adjustment_alteration
  adjustment_cancellation
  adjustment_deviation
  adjustment_other
  adjustment_resolution
  commission_management
  commission_ota
  commission_other
  commission_pms
  exception_paymentDeviation
  exception_reservationAmountZero
  exception_reservationDeviation
  paymentFee_card
  paymentFee_currencyConversion
  paymentFee_other
  paymentFee_transaction
  revenue_accommodation
  revenue_cleaning
  revenue_extra
  revenue_other
  securityDeposit_deposit
  securityDeposit_fee
  tax_city
  tax_local
  tax_other
  tax_tourism
  tax_vat
}

"""
Boolean expression to compare columns of type "subclassification_enum". All fields are combined with logical 'AND'.
"""
input subclassification_enum_comparison_exp {
  _eq: subclassification_enum
  _in: [subclassification_enum!]
  _is_null: Boolean
  _neq: subclassification_enum
  _nin: [subclassification_enum!]
}

"""
input type for inserting data into table "subclassification"
"""
input subclassification_insert_input {
  name: String
}

"""aggregate max on columns"""
type subclassification_max_fields {
  name: String
}

"""aggregate min on columns"""
type subclassification_min_fields {
  name: String
}

"""
response of any mutation on the table "subclassification"
"""
type subclassification_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [subclassification!]!
}

"""
on conflict condition type for table "subclassification"
"""
input subclassification_on_conflict {
  constraint: subclassification_constraint!
  update_columns: [subclassification_update_column!]! = []
  where: subclassification_bool_exp
}

"""Ordering options when selecting data from "subclassification"."""
input subclassification_order_by {
  name: order_by
}

"""primary key columns input for table: subclassification"""
input subclassification_pk_columns_input {
  name: String!
}

"""
select columns of table "subclassification"
"""
enum subclassification_select_column {
  """column name"""
  name
}

"""
input type for updating data in table "subclassification"
"""
input subclassification_set_input {
  name: String
}

"""
update columns of table "subclassification"
"""
enum subclassification_update_column {
  """column name"""
  name
}

type subscription_root {
  """
  fetch aggregated fields from the table: "booking_status"
  """
  aggregateBookingStatuses(
    """distinct select on columns"""
    distinct_on: [bookingStatus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bookingStatus_order_by!]

    """filter the rows returned"""
    where: bookingStatus_bool_exp
  ): bookingStatus_aggregate!

  """
  fetch aggregated fields from the table: "booking"
  """
  aggregateBookings(
    """distinct select on columns"""
    distinct_on: [booking_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_order_by!]

    """filter the rows returned"""
    where: booking_bool_exp
  ): booking_aggregate!

  """
  fetch aggregated fields from the table: "classification"
  """
  aggregateClassifications(
    """distinct select on columns"""
    distinct_on: [classification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [classification_order_by!]

    """filter the rows returned"""
    where: classification_bool_exp
  ): classification_aggregate!

  """
  fetch aggregated fields from the table: "connection"
  """
  aggregateConnections(
    """distinct select on columns"""
    distinct_on: [connection_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [connection_order_by!]

    """filter the rows returned"""
    where: connection_bool_exp
  ): connection_aggregate!

  """
  fetch aggregated fields from the table: "currency"
  """
  aggregateCurrencies(
    """distinct select on columns"""
    distinct_on: [currency_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [currency_order_by!]

    """filter the rows returned"""
    where: currency_bool_exp
  ): currency_aggregate!

  """
  fetch aggregated fields from the table: "entity"
  """
  aggregateEntities(
    """distinct select on columns"""
    distinct_on: [entity_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [entity_order_by!]

    """filter the rows returned"""
    where: entity_bool_exp
  ): entity_aggregate!

  """
  fetch aggregated fields from the table: "entity_status"
  """
  aggregateEntityStatuses(
    """distinct select on columns"""
    distinct_on: [entityStatus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [entityStatus_order_by!]

    """filter the rows returned"""
    where: entityStatus_bool_exp
  ): entityStatus_aggregate!

  """
  fetch aggregated fields from the table: "integration_type"
  """
  aggregateIntegrationTypes(
    """distinct select on columns"""
    distinct_on: [integrationType_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationType_order_by!]

    """filter the rows returned"""
    where: integrationType_bool_exp
  ): integrationType_aggregate!

  """
  fetch aggregated fields from the table: "integration"
  """
  aggregateIntegrations(
    """distinct select on columns"""
    distinct_on: [integration_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integration_order_by!]

    """filter the rows returned"""
    where: integration_bool_exp
  ): integration_aggregate!

  """
  fetch aggregated fields from the table: "issue"
  """
  aggregateIssues(
    """distinct select on columns"""
    distinct_on: [issue_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [issue_order_by!]

    """filter the rows returned"""
    where: issue_bool_exp
  ): issue_aggregate!

  """
  fetch aggregated fields from the table: "job_method"
  """
  aggregateJobMethods(
    """distinct select on columns"""
    distinct_on: [jobMethod_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [jobMethod_order_by!]

    """filter the rows returned"""
    where: jobMethod_bool_exp
  ): jobMethod_aggregate!

  """
  fetch aggregated fields from the table: "job_status"
  """
  aggregateJobStatuses(
    """distinct select on columns"""
    distinct_on: [jobStatus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [jobStatus_order_by!]

    """filter the rows returned"""
    where: jobStatus_bool_exp
  ): jobStatus_aggregate!

  """
  fetch aggregated fields from the table: "job"
  """
  aggregateJobs(
    """distinct select on columns"""
    distinct_on: [job_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [job_order_by!]

    """filter the rows returned"""
    where: job_bool_exp
  ): job_aggregate!

  """
  fetch aggregated fields from the table: "line"
  """
  aggregateLines(
    """distinct select on columns"""
    distinct_on: [line_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [line_order_by!]

    """filter the rows returned"""
    where: line_bool_exp
  ): line_aggregate!

  """
  fetch aggregated fields from the table: "metric"
  """
  aggregateMetrics(
    """distinct select on columns"""
    distinct_on: [metric_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [metric_order_by!]

    """filter the rows returned"""
    where: metric_bool_exp
  ): metric_aggregate!

  """
  fetch aggregated fields from the table: "normalized_type"
  """
  aggregateNormalizedTypes(
    """distinct select on columns"""
    distinct_on: [normalizedType_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [normalizedType_order_by!]

    """filter the rows returned"""
    where: normalizedType_bool_exp
  ): normalizedType_aggregate!

  """
  fetch aggregated fields from the table: "payment_status"
  """
  aggregatePaymentStatuses(
    """distinct select on columns"""
    distinct_on: [paymentStatus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [paymentStatus_order_by!]

    """filter the rows returned"""
    where: paymentStatus_bool_exp
  ): paymentStatus_aggregate!

  """
  fetch aggregated fields from the table: "payment_type"
  """
  aggregatePaymentTypes(
    """distinct select on columns"""
    distinct_on: [paymentType_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [paymentType_order_by!]

    """filter the rows returned"""
    where: paymentType_bool_exp
  ): paymentType_aggregate!

  """
  fetch aggregated fields from the table: "payment"
  """
  aggregatePayments(
    """distinct select on columns"""
    distinct_on: [payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_order_by!]

    """filter the rows returned"""
    where: payment_bool_exp
  ): payment_aggregate!

  """
  fetch aggregated fields from the table: "subclassification"
  """
  aggregateSubclassifications(
    """distinct select on columns"""
    distinct_on: [subclassification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subclassification_order_by!]

    """filter the rows returned"""
    where: subclassification_bool_exp
  ): subclassification_aggregate!

  """
  fetch aggregated fields from the table: "tag"
  """
  aggregateTags(
    """distinct select on columns"""
    distinct_on: [tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tag_order_by!]

    """filter the rows returned"""
    where: tag_bool_exp
  ): tag_aggregate!

  """
  fetch aggregated fields from the table: "team_user"
  """
  aggregateTeamUsers(
    """distinct select on columns"""
    distinct_on: [teamUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamUser_order_by!]

    """filter the rows returned"""
    where: teamUser_bool_exp
  ): teamUser_aggregate!

  """
  fetch aggregated fields from the table: "team"
  """
  aggregateTeams(
    """distinct select on columns"""
    distinct_on: [team_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [team_order_by!]

    """filter the rows returned"""
    where: team_bool_exp
  ): team_aggregate!

  """
  fetch aggregated fields from the table: "unit"
  """
  aggregateUnits(
    """distinct select on columns"""
    distinct_on: [unit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [unit_order_by!]

    """filter the rows returned"""
    where: unit_bool_exp
  ): unit_aggregate!

  """
  fetch aggregated fields from the table: "user_status"
  """
  aggregateUserStatuses(
    """distinct select on columns"""
    distinct_on: [userStatus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userStatus_order_by!]

    """filter the rows returned"""
    where: userStatus_bool_exp
  ): userStatus_aggregate!

  """
  fetch aggregated fields from the table: "user"
  """
  aggregateUsers(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): user_aggregate!

  """
  fetch aggregated fields from the table: "webhook"
  """
  aggregateWebhooks(
    """distinct select on columns"""
    distinct_on: [webhook_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [webhook_order_by!]

    """filter the rows returned"""
    where: webhook_bool_exp
  ): webhook_aggregate!

  """fetch data from the table: "booking" using primary key columns"""
  booking(id: uuid!): booking

  """fetch data from the table: "booking_status" using primary key columns"""
  bookingStatus(name: String!): bookingStatus

  """
  fetch data from the table: "booking_status"
  """
  bookingStatuses(
    """distinct select on columns"""
    distinct_on: [bookingStatus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bookingStatus_order_by!]

    """filter the rows returned"""
    where: bookingStatus_bool_exp
  ): [bookingStatus!]!

  """
  fetch data from the table: "booking_channel"
  """
  booking_channel(
    """distinct select on columns"""
    distinct_on: [booking_channel_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_channel_order_by!]

    """filter the rows returned"""
    where: booking_channel_bool_exp
  ): [booking_channel!]!

  """
  fetch aggregated fields from the table: "booking_channel"
  """
  booking_channel_aggregate(
    """distinct select on columns"""
    distinct_on: [booking_channel_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_channel_order_by!]

    """filter the rows returned"""
    where: booking_channel_bool_exp
  ): booking_channel_aggregate!

  """fetch data from the table: "booking_channel" using primary key columns"""
  booking_channel_by_pk(name: String!): booking_channel

  """An array relationship"""
  bookings(
    """distinct select on columns"""
    distinct_on: [booking_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_order_by!]

    """filter the rows returned"""
    where: booking_bool_exp
  ): [booking!]!

  """fetch data from the table: "classification" using primary key columns"""
  classification(name: String!): classification

  """
  fetch data from the table: "classification"
  """
  classifications(
    """distinct select on columns"""
    distinct_on: [classification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [classification_order_by!]

    """filter the rows returned"""
    where: classification_bool_exp
  ): [classification!]!

  """fetch data from the table: "connection" using primary key columns"""
  connection(id: uuid!): connection

  """An array relationship"""
  connections(
    """distinct select on columns"""
    distinct_on: [connection_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [connection_order_by!]

    """filter the rows returned"""
    where: connection_bool_exp
  ): [connection!]!

  """
  fetch data from the table: "currency"
  """
  currencies(
    """distinct select on columns"""
    distinct_on: [currency_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [currency_order_by!]

    """filter the rows returned"""
    where: currency_bool_exp
  ): [currency!]!

  """fetch data from the table: "currency" using primary key columns"""
  currency(name: String!): currency

  """An array relationship"""
  entities(
    """distinct select on columns"""
    distinct_on: [entity_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [entity_order_by!]

    """filter the rows returned"""
    where: entity_bool_exp
  ): [entity!]!

  """fetch data from the table: "entity" using primary key columns"""
  entity(id: uuid!): entity

  """fetch data from the table: "entity_status" using primary key columns"""
  entityStatus(name: String!): entityStatus

  """
  fetch data from the table: "entity_status"
  """
  entityStatuses(
    """distinct select on columns"""
    distinct_on: [entityStatus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [entityStatus_order_by!]

    """filter the rows returned"""
    where: entityStatus_bool_exp
  ): [entityStatus!]!

  """fetch data from the table: "integration" using primary key columns"""
  integration(id: uuid!): integration

  """
  fetch data from the table: "integration_type" using primary key columns
  """
  integrationType(name: String!): integrationType

  """
  fetch data from the table: "integration_type"
  """
  integrationTypes(
    """distinct select on columns"""
    distinct_on: [integrationType_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integrationType_order_by!]

    """filter the rows returned"""
    where: integrationType_bool_exp
  ): [integrationType!]!

  """An array relationship"""
  integrations(
    """distinct select on columns"""
    distinct_on: [integration_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integration_order_by!]

    """filter the rows returned"""
    where: integration_bool_exp
  ): [integration!]!

  """fetch data from the table: "issue" using primary key columns"""
  issue(id: uuid!): issue

  """An array relationship"""
  issues(
    """distinct select on columns"""
    distinct_on: [issue_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [issue_order_by!]

    """filter the rows returned"""
    where: issue_bool_exp
  ): [issue!]!

  """fetch data from the table: "job" using primary key columns"""
  job(id: uuid!): job

  """fetch data from the table: "job_method" using primary key columns"""
  jobMethod(name: String!): jobMethod

  """
  fetch data from the table: "job_method"
  """
  jobMethods(
    """distinct select on columns"""
    distinct_on: [jobMethod_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [jobMethod_order_by!]

    """filter the rows returned"""
    where: jobMethod_bool_exp
  ): [jobMethod!]!

  """fetch data from the table: "job_status" using primary key columns"""
  jobStatus(name: String!): jobStatus

  """
  fetch data from the table: "job_status"
  """
  jobStatuses(
    """distinct select on columns"""
    distinct_on: [jobStatus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [jobStatus_order_by!]

    """filter the rows returned"""
    where: jobStatus_bool_exp
  ): [jobStatus!]!

  """An array relationship"""
  jobs(
    """distinct select on columns"""
    distinct_on: [job_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [job_order_by!]

    """filter the rows returned"""
    where: job_bool_exp
  ): [job!]!

  """fetch data from the table: "line" using primary key columns"""
  line(id: uuid!): line

  """An array relationship"""
  lines(
    """distinct select on columns"""
    distinct_on: [line_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [line_order_by!]

    """filter the rows returned"""
    where: line_bool_exp
  ): [line!]!

  """fetch data from the table: "metric" using primary key columns"""
  metric(id: uuid!): metric

  """An array relationship"""
  metrics(
    """distinct select on columns"""
    distinct_on: [metric_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [metric_order_by!]

    """filter the rows returned"""
    where: metric_bool_exp
  ): [metric!]!

  """fetch data from the table: "normalized_type" using primary key columns"""
  normalizedType(name: String!): normalizedType

  """
  fetch data from the table: "normalized_type"
  """
  normalizedTypes(
    """distinct select on columns"""
    distinct_on: [normalizedType_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [normalizedType_order_by!]

    """filter the rows returned"""
    where: normalizedType_bool_exp
  ): [normalizedType!]!

  """fetch data from the table: "payment" using primary key columns"""
  payment(id: uuid!): payment

  """fetch data from the table: "payment_status" using primary key columns"""
  paymentStatus(name: String!): paymentStatus

  """
  fetch data from the table: "payment_status"
  """
  paymentStatuses(
    """distinct select on columns"""
    distinct_on: [paymentStatus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [paymentStatus_order_by!]

    """filter the rows returned"""
    where: paymentStatus_bool_exp
  ): [paymentStatus!]!

  """fetch data from the table: "payment_type" using primary key columns"""
  paymentType(name: String!): paymentType

  """
  fetch data from the table: "payment_type"
  """
  paymentTypes(
    """distinct select on columns"""
    distinct_on: [paymentType_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [paymentType_order_by!]

    """filter the rows returned"""
    where: paymentType_bool_exp
  ): [paymentType!]!

  """An array relationship"""
  payments(
    """distinct select on columns"""
    distinct_on: [payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_order_by!]

    """filter the rows returned"""
    where: payment_bool_exp
  ): [payment!]!

  """
  fetch data from the table: "subclassification" using primary key columns
  """
  subclassification(name: String!): subclassification

  """
  fetch data from the table: "subclassification"
  """
  subclassifications(
    """distinct select on columns"""
    distinct_on: [subclassification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subclassification_order_by!]

    """filter the rows returned"""
    where: subclassification_bool_exp
  ): [subclassification!]!

  """fetch data from the table: "tag" using primary key columns"""
  tag(id: uuid!): tag

  """An array relationship"""
  tags(
    """distinct select on columns"""
    distinct_on: [tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tag_order_by!]

    """filter the rows returned"""
    where: tag_bool_exp
  ): [tag!]!

  """fetch data from the table: "team" using primary key columns"""
  team(id: uuid!): team

  """fetch data from the table: "team_user" using primary key columns"""
  teamUser(id: uuid!): teamUser

  """
  fetch data from the table: "team_user"
  """
  teamUsers(
    """distinct select on columns"""
    distinct_on: [teamUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamUser_order_by!]

    """filter the rows returned"""
    where: teamUser_bool_exp
  ): [teamUser!]!

  """
  fetch data from the table: "team"
  """
  teams(
    """distinct select on columns"""
    distinct_on: [team_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [team_order_by!]

    """filter the rows returned"""
    where: team_bool_exp
  ): [team!]!

  """fetch data from the table: "unit" using primary key columns"""
  unit(id: uuid!): unit

  """An array relationship"""
  units(
    """distinct select on columns"""
    distinct_on: [unit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [unit_order_by!]

    """filter the rows returned"""
    where: unit_bool_exp
  ): [unit!]!

  """fetch data from the table: "user" using primary key columns"""
  user(id: uuid!): user

  """fetch data from the table: "user_status" using primary key columns"""
  userStatus(name: String!): userStatus

  """
  fetch data from the table: "user_status"
  """
  userStatuses(
    """distinct select on columns"""
    distinct_on: [userStatus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [userStatus_order_by!]

    """filter the rows returned"""
    where: userStatus_bool_exp
  ): [userStatus!]!

  """
  fetch data from the table: "user"
  """
  users(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """fetch data from the table: "webhook" using primary key columns"""
  webhook(id: uuid!): webhook

  """An array relationship"""
  webhooks(
    """distinct select on columns"""
    distinct_on: [webhook_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [webhook_order_by!]

    """filter the rows returned"""
    where: webhook_bool_exp
  ): [webhook!]!
}

"""
columns and relationships of "tag"
"""
type tag {
  """An object relationship"""
  booking: booking!
  bookingId: uuid!

  """An object relationship"""
  connection: connection!
  connectionId: uuid!
  createdAt: timestamptz
  id: uuid!
  json(
    """JSON select path"""
    path: String
  ): jsonb!

  """An object relationship"""
  payment: payment!
  paymentId: uuid!

  """An object relationship"""
  team: team!
  teamId: uuid!
  type: String!
  uniqueRef: String!

  """An object relationship"""
  unit: unit!
  unitId: uuid!
  updatedAt: timestamptz
}

"""
aggregated selection of "tag"
"""
type tag_aggregate {
  aggregate: tag_aggregate_fields
  nodes: [tag!]!
}

"""
aggregate fields of "tag"
"""
type tag_aggregate_fields {
  count(columns: [tag_select_column!], distinct: Boolean): Int!
  max: tag_max_fields
  min: tag_min_fields
}

"""
order by aggregate values of table "tag"
"""
input tag_aggregate_order_by {
  count: order_by
  max: tag_max_order_by
  min: tag_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input tag_append_input {
  json: jsonb
}

"""
input type for inserting array relation for remote table "tag"
"""
input tag_arr_rel_insert_input {
  data: [tag_insert_input!]!

  """on conflict condition"""
  on_conflict: tag_on_conflict
}

"""
Boolean expression to filter rows from the table "tag". All fields are combined with a logical 'AND'.
"""
input tag_bool_exp {
  _and: [tag_bool_exp!]
  _not: tag_bool_exp
  _or: [tag_bool_exp!]
  booking: booking_bool_exp
  bookingId: uuid_comparison_exp
  connection: connection_bool_exp
  connectionId: uuid_comparison_exp
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  json: jsonb_comparison_exp
  payment: payment_bool_exp
  paymentId: uuid_comparison_exp
  team: team_bool_exp
  teamId: uuid_comparison_exp
  type: String_comparison_exp
  uniqueRef: String_comparison_exp
  unit: unit_bool_exp
  unitId: uuid_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "tag"
"""
enum tag_constraint {
  """unique or primary key constraint"""
  tag_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input tag_delete_at_path_input {
  json: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input tag_delete_elem_input {
  json: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input tag_delete_key_input {
  json: String
}

"""
input type for inserting data into table "tag"
"""
input tag_insert_input {
  booking: booking_obj_rel_insert_input
  bookingId: uuid
  connection: connection_obj_rel_insert_input
  connectionId: uuid
  createdAt: timestamptz
  id: uuid
  json: jsonb
  payment: payment_obj_rel_insert_input
  paymentId: uuid
  team: team_obj_rel_insert_input
  teamId: uuid
  type: String
  uniqueRef: String
  unit: unit_obj_rel_insert_input
  unitId: uuid
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type tag_max_fields {
  bookingId: uuid
  connectionId: uuid
  createdAt: timestamptz
  id: uuid
  paymentId: uuid
  teamId: uuid
  type: String
  uniqueRef: String
  unitId: uuid
  updatedAt: timestamptz
}

"""
order by max() on columns of table "tag"
"""
input tag_max_order_by {
  bookingId: order_by
  connectionId: order_by
  createdAt: order_by
  id: order_by
  paymentId: order_by
  teamId: order_by
  type: order_by
  uniqueRef: order_by
  unitId: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type tag_min_fields {
  bookingId: uuid
  connectionId: uuid
  createdAt: timestamptz
  id: uuid
  paymentId: uuid
  teamId: uuid
  type: String
  uniqueRef: String
  unitId: uuid
  updatedAt: timestamptz
}

"""
order by min() on columns of table "tag"
"""
input tag_min_order_by {
  bookingId: order_by
  connectionId: order_by
  createdAt: order_by
  id: order_by
  paymentId: order_by
  teamId: order_by
  type: order_by
  uniqueRef: order_by
  unitId: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "tag"
"""
type tag_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [tag!]!
}

"""
on conflict condition type for table "tag"
"""
input tag_on_conflict {
  constraint: tag_constraint!
  update_columns: [tag_update_column!]! = []
  where: tag_bool_exp
}

"""Ordering options when selecting data from "tag"."""
input tag_order_by {
  booking: booking_order_by
  bookingId: order_by
  connection: connection_order_by
  connectionId: order_by
  createdAt: order_by
  id: order_by
  json: order_by
  payment: payment_order_by
  paymentId: order_by
  team: team_order_by
  teamId: order_by
  type: order_by
  uniqueRef: order_by
  unit: unit_order_by
  unitId: order_by
  updatedAt: order_by
}

"""primary key columns input for table: tag"""
input tag_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input tag_prepend_input {
  json: jsonb
}

"""
select columns of table "tag"
"""
enum tag_select_column {
  """column name"""
  bookingId

  """column name"""
  connectionId

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  json

  """column name"""
  paymentId

  """column name"""
  teamId

  """column name"""
  type

  """column name"""
  uniqueRef

  """column name"""
  unitId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "tag"
"""
input tag_set_input {
  bookingId: uuid
  connectionId: uuid
  createdAt: timestamptz
  id: uuid
  json: jsonb
  paymentId: uuid
  teamId: uuid
  type: String
  uniqueRef: String
  unitId: uuid
  updatedAt: timestamptz
}

"""
update columns of table "tag"
"""
enum tag_update_column {
  """column name"""
  bookingId

  """column name"""
  connectionId

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  json

  """column name"""
  paymentId

  """column name"""
  teamId

  """column name"""
  type

  """column name"""
  uniqueRef

  """column name"""
  unitId

  """column name"""
  updatedAt
}

"""
columns and relationships of "team"
"""
type team {
  address: String

  """An array relationship"""
  bookings(
    """distinct select on columns"""
    distinct_on: [booking_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_order_by!]

    """filter the rows returned"""
    where: booking_bool_exp
  ): [booking!]!

  """An aggregate relationship"""
  bookings_aggregate(
    """distinct select on columns"""
    distinct_on: [booking_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_order_by!]

    """filter the rows returned"""
    where: booking_bool_exp
  ): booking_aggregate!
  commissionPercentage: numeric

  """An array relationship"""
  connections(
    """distinct select on columns"""
    distinct_on: [connection_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [connection_order_by!]

    """filter the rows returned"""
    where: connection_bool_exp
  ): [connection!]!

  """An aggregate relationship"""
  connections_aggregate(
    """distinct select on columns"""
    distinct_on: [connection_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [connection_order_by!]

    """filter the rows returned"""
    where: connection_bool_exp
  ): connection_aggregate!
  createdAt: timestamptz!
  email: String

  """An array relationship"""
  entities(
    """distinct select on columns"""
    distinct_on: [entity_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [entity_order_by!]

    """filter the rows returned"""
    where: entity_bool_exp
  ): [entity!]!

  """An aggregate relationship"""
  entities_aggregate(
    """distinct select on columns"""
    distinct_on: [entity_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [entity_order_by!]

    """filter the rows returned"""
    where: entity_bool_exp
  ): entity_aggregate!
  id: uuid!

  """An array relationship"""
  integrations(
    """distinct select on columns"""
    distinct_on: [integration_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integration_order_by!]

    """filter the rows returned"""
    where: integration_bool_exp
  ): [integration!]!

  """An aggregate relationship"""
  integrations_aggregate(
    """distinct select on columns"""
    distinct_on: [integration_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [integration_order_by!]

    """filter the rows returned"""
    where: integration_bool_exp
  ): integration_aggregate!
  isActive: Boolean
  isTest: Boolean

  """An array relationship"""
  issues(
    """distinct select on columns"""
    distinct_on: [issue_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [issue_order_by!]

    """filter the rows returned"""
    where: issue_bool_exp
  ): [issue!]!

  """An aggregate relationship"""
  issues_aggregate(
    """distinct select on columns"""
    distinct_on: [issue_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [issue_order_by!]

    """filter the rows returned"""
    where: issue_bool_exp
  ): issue_aggregate!

  """An array relationship"""
  jobs(
    """distinct select on columns"""
    distinct_on: [job_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [job_order_by!]

    """filter the rows returned"""
    where: job_bool_exp
  ): [job!]!

  """An aggregate relationship"""
  jobs_aggregate(
    """distinct select on columns"""
    distinct_on: [job_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [job_order_by!]

    """filter the rows returned"""
    where: job_bool_exp
  ): job_aggregate!

  """An array relationship"""
  lines(
    """distinct select on columns"""
    distinct_on: [line_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [line_order_by!]

    """filter the rows returned"""
    where: line_bool_exp
  ): [line!]!

  """An aggregate relationship"""
  lines_aggregate(
    """distinct select on columns"""
    distinct_on: [line_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [line_order_by!]

    """filter the rows returned"""
    where: line_bool_exp
  ): line_aggregate!

  """An array relationship"""
  members(
    """distinct select on columns"""
    distinct_on: [teamUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamUser_order_by!]

    """filter the rows returned"""
    where: teamUser_bool_exp
  ): [teamUser!]!

  """An aggregate relationship"""
  members_aggregate(
    """distinct select on columns"""
    distinct_on: [teamUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamUser_order_by!]

    """filter the rows returned"""
    where: teamUser_bool_exp
  ): teamUser_aggregate!

  """An array relationship"""
  metrics(
    """distinct select on columns"""
    distinct_on: [metric_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [metric_order_by!]

    """filter the rows returned"""
    where: metric_bool_exp
  ): [metric!]!

  """An aggregate relationship"""
  metrics_aggregate(
    """distinct select on columns"""
    distinct_on: [metric_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [metric_order_by!]

    """filter the rows returned"""
    where: metric_bool_exp
  ): metric_aggregate!
  name: String!

  """An array relationship"""
  payments(
    """distinct select on columns"""
    distinct_on: [payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_order_by!]

    """filter the rows returned"""
    where: payment_bool_exp
  ): [payment!]!

  """An aggregate relationship"""
  payments_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_order_by!]

    """filter the rows returned"""
    where: payment_bool_exp
  ): payment_aggregate!
  stripeId: String
  stripeSubscriptionItemId: String
  supportEmail: String
  supportPhone: String

  """An array relationship"""
  tags(
    """distinct select on columns"""
    distinct_on: [tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tag_order_by!]

    """filter the rows returned"""
    where: tag_bool_exp
  ): [tag!]!

  """An aggregate relationship"""
  tags_aggregate(
    """distinct select on columns"""
    distinct_on: [tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tag_order_by!]

    """filter the rows returned"""
    where: tag_bool_exp
  ): tag_aggregate!

  """An array relationship"""
  units(
    """distinct select on columns"""
    distinct_on: [unit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [unit_order_by!]

    """filter the rows returned"""
    where: unit_bool_exp
  ): [unit!]!

  """An aggregate relationship"""
  units_aggregate(
    """distinct select on columns"""
    distinct_on: [unit_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [unit_order_by!]

    """filter the rows returned"""
    where: unit_bool_exp
  ): unit_aggregate!

  """An array relationship"""
  webhooks(
    """distinct select on columns"""
    distinct_on: [webhook_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [webhook_order_by!]

    """filter the rows returned"""
    where: webhook_bool_exp
  ): [webhook!]!

  """An aggregate relationship"""
  webhooks_aggregate(
    """distinct select on columns"""
    distinct_on: [webhook_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [webhook_order_by!]

    """filter the rows returned"""
    where: webhook_bool_exp
  ): webhook_aggregate!
  website: String
}

"""
aggregated selection of "team"
"""
type team_aggregate {
  aggregate: team_aggregate_fields
  nodes: [team!]!
}

"""
aggregate fields of "team"
"""
type team_aggregate_fields {
  avg: team_avg_fields
  count(columns: [team_select_column!], distinct: Boolean): Int!
  max: team_max_fields
  min: team_min_fields
  stddev: team_stddev_fields
  stddev_pop: team_stddev_pop_fields
  stddev_samp: team_stddev_samp_fields
  sum: team_sum_fields
  var_pop: team_var_pop_fields
  var_samp: team_var_samp_fields
  variance: team_variance_fields
}

"""aggregate avg on columns"""
type team_avg_fields {
  commissionPercentage: Float
}

"""
Boolean expression to filter rows from the table "team". All fields are combined with a logical 'AND'.
"""
input team_bool_exp {
  _and: [team_bool_exp!]
  _not: team_bool_exp
  _or: [team_bool_exp!]
  address: String_comparison_exp
  bookings: booking_bool_exp
  commissionPercentage: numeric_comparison_exp
  connections: connection_bool_exp
  createdAt: timestamptz_comparison_exp
  email: String_comparison_exp
  entities: entity_bool_exp
  id: uuid_comparison_exp
  integrations: integration_bool_exp
  isActive: Boolean_comparison_exp
  isTest: Boolean_comparison_exp
  issues: issue_bool_exp
  jobs: job_bool_exp
  lines: line_bool_exp
  members: teamUser_bool_exp
  metrics: metric_bool_exp
  name: String_comparison_exp
  payments: payment_bool_exp
  stripeId: String_comparison_exp
  stripeSubscriptionItemId: String_comparison_exp
  supportEmail: String_comparison_exp
  supportPhone: String_comparison_exp
  tags: tag_bool_exp
  units: unit_bool_exp
  webhooks: webhook_bool_exp
  website: String_comparison_exp
}

"""
unique or primary key constraints on table "team"
"""
enum team_constraint {
  """unique or primary key constraint"""
  team_pkey
}

"""
input type for incrementing numeric columns in table "team"
"""
input team_inc_input {
  commissionPercentage: numeric
}

"""
input type for inserting data into table "team"
"""
input team_insert_input {
  address: String
  bookings: booking_arr_rel_insert_input
  commissionPercentage: numeric
  connections: connection_arr_rel_insert_input
  createdAt: timestamptz
  email: String
  entities: entity_arr_rel_insert_input
  id: uuid
  integrations: integration_arr_rel_insert_input
  isActive: Boolean
  isTest: Boolean
  issues: issue_arr_rel_insert_input
  jobs: job_arr_rel_insert_input
  lines: line_arr_rel_insert_input
  members: teamUser_arr_rel_insert_input
  metrics: metric_arr_rel_insert_input
  name: String
  payments: payment_arr_rel_insert_input
  stripeId: String
  stripeSubscriptionItemId: String
  supportEmail: String
  supportPhone: String
  tags: tag_arr_rel_insert_input
  units: unit_arr_rel_insert_input
  webhooks: webhook_arr_rel_insert_input
  website: String
}

"""aggregate max on columns"""
type team_max_fields {
  address: String
  commissionPercentage: numeric
  createdAt: timestamptz
  email: String
  id: uuid
  name: String
  stripeId: String
  stripeSubscriptionItemId: String
  supportEmail: String
  supportPhone: String
  website: String
}

"""aggregate min on columns"""
type team_min_fields {
  address: String
  commissionPercentage: numeric
  createdAt: timestamptz
  email: String
  id: uuid
  name: String
  stripeId: String
  stripeSubscriptionItemId: String
  supportEmail: String
  supportPhone: String
  website: String
}

"""
response of any mutation on the table "team"
"""
type team_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [team!]!
}

"""
input type for inserting object relation for remote table "team"
"""
input team_obj_rel_insert_input {
  data: team_insert_input!

  """on conflict condition"""
  on_conflict: team_on_conflict
}

"""
on conflict condition type for table "team"
"""
input team_on_conflict {
  constraint: team_constraint!
  update_columns: [team_update_column!]! = []
  where: team_bool_exp
}

"""Ordering options when selecting data from "team"."""
input team_order_by {
  address: order_by
  bookings_aggregate: booking_aggregate_order_by
  commissionPercentage: order_by
  connections_aggregate: connection_aggregate_order_by
  createdAt: order_by
  email: order_by
  entities_aggregate: entity_aggregate_order_by
  id: order_by
  integrations_aggregate: integration_aggregate_order_by
  isActive: order_by
  isTest: order_by
  issues_aggregate: issue_aggregate_order_by
  jobs_aggregate: job_aggregate_order_by
  lines_aggregate: line_aggregate_order_by
  members_aggregate: teamUser_aggregate_order_by
  metrics_aggregate: metric_aggregate_order_by
  name: order_by
  payments_aggregate: payment_aggregate_order_by
  stripeId: order_by
  stripeSubscriptionItemId: order_by
  supportEmail: order_by
  supportPhone: order_by
  tags_aggregate: tag_aggregate_order_by
  units_aggregate: unit_aggregate_order_by
  webhooks_aggregate: webhook_aggregate_order_by
  website: order_by
}

"""primary key columns input for table: team"""
input team_pk_columns_input {
  id: uuid!
}

"""
select columns of table "team"
"""
enum team_select_column {
  """column name"""
  address

  """column name"""
  commissionPercentage

  """column name"""
  createdAt

  """column name"""
  email

  """column name"""
  id

  """column name"""
  isActive

  """column name"""
  isTest

  """column name"""
  name

  """column name"""
  stripeId

  """column name"""
  stripeSubscriptionItemId

  """column name"""
  supportEmail

  """column name"""
  supportPhone

  """column name"""
  website
}

"""
input type for updating data in table "team"
"""
input team_set_input {
  address: String
  commissionPercentage: numeric
  createdAt: timestamptz
  email: String
  id: uuid
  isActive: Boolean
  isTest: Boolean
  name: String
  stripeId: String
  stripeSubscriptionItemId: String
  supportEmail: String
  supportPhone: String
  website: String
}

"""aggregate stddev on columns"""
type team_stddev_fields {
  commissionPercentage: Float
}

"""aggregate stddev_pop on columns"""
type team_stddev_pop_fields {
  commissionPercentage: Float
}

"""aggregate stddev_samp on columns"""
type team_stddev_samp_fields {
  commissionPercentage: Float
}

"""aggregate sum on columns"""
type team_sum_fields {
  commissionPercentage: numeric
}

"""
update columns of table "team"
"""
enum team_update_column {
  """column name"""
  address

  """column name"""
  commissionPercentage

  """column name"""
  createdAt

  """column name"""
  email

  """column name"""
  id

  """column name"""
  isActive

  """column name"""
  isTest

  """column name"""
  name

  """column name"""
  stripeId

  """column name"""
  stripeSubscriptionItemId

  """column name"""
  supportEmail

  """column name"""
  supportPhone

  """column name"""
  website
}

"""aggregate var_pop on columns"""
type team_var_pop_fields {
  commissionPercentage: Float
}

"""aggregate var_samp on columns"""
type team_var_samp_fields {
  commissionPercentage: Float
}

"""aggregate variance on columns"""
type team_variance_fields {
  commissionPercentage: Float
}

"""
columns and relationships of "team_user"
"""
type teamUser {
  createdAt: timestamptz
  id: uuid!
  role: String

  """An object relationship"""
  team: team!
  teamId: uuid!
  updatedAt: timestamptz

  """An object relationship"""
  user: user!
  userId: uuid!
}

"""
aggregated selection of "team_user"
"""
type teamUser_aggregate {
  aggregate: teamUser_aggregate_fields
  nodes: [teamUser!]!
}

"""
aggregate fields of "team_user"
"""
type teamUser_aggregate_fields {
  count(columns: [teamUser_select_column!], distinct: Boolean): Int!
  max: teamUser_max_fields
  min: teamUser_min_fields
}

"""
order by aggregate values of table "team_user"
"""
input teamUser_aggregate_order_by {
  count: order_by
  max: teamUser_max_order_by
  min: teamUser_min_order_by
}

"""
input type for inserting array relation for remote table "team_user"
"""
input teamUser_arr_rel_insert_input {
  data: [teamUser_insert_input!]!

  """on conflict condition"""
  on_conflict: teamUser_on_conflict
}

"""
Boolean expression to filter rows from the table "team_user". All fields are combined with a logical 'AND'.
"""
input teamUser_bool_exp {
  _and: [teamUser_bool_exp!]
  _not: teamUser_bool_exp
  _or: [teamUser_bool_exp!]
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  role: String_comparison_exp
  team: team_bool_exp
  teamId: uuid_comparison_exp
  updatedAt: timestamptz_comparison_exp
  user: user_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "team_user"
"""
enum teamUser_constraint {
  """unique or primary key constraint"""
  team_user_pkey
}

"""
input type for inserting data into table "team_user"
"""
input teamUser_insert_input {
  createdAt: timestamptz
  id: uuid
  role: String
  team: team_obj_rel_insert_input
  teamId: uuid
  updatedAt: timestamptz
  user: user_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type teamUser_max_fields {
  createdAt: timestamptz
  id: uuid
  role: String
  teamId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""
order by max() on columns of table "team_user"
"""
input teamUser_max_order_by {
  createdAt: order_by
  id: order_by
  role: order_by
  teamId: order_by
  updatedAt: order_by
  userId: order_by
}

"""aggregate min on columns"""
type teamUser_min_fields {
  createdAt: timestamptz
  id: uuid
  role: String
  teamId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""
order by min() on columns of table "team_user"
"""
input teamUser_min_order_by {
  createdAt: order_by
  id: order_by
  role: order_by
  teamId: order_by
  updatedAt: order_by
  userId: order_by
}

"""
response of any mutation on the table "team_user"
"""
type teamUser_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [teamUser!]!
}

"""
on conflict condition type for table "team_user"
"""
input teamUser_on_conflict {
  constraint: teamUser_constraint!
  update_columns: [teamUser_update_column!]! = []
  where: teamUser_bool_exp
}

"""Ordering options when selecting data from "team_user"."""
input teamUser_order_by {
  createdAt: order_by
  id: order_by
  role: order_by
  team: team_order_by
  teamId: order_by
  updatedAt: order_by
  user: user_order_by
  userId: order_by
}

"""primary key columns input for table: teamUser"""
input teamUser_pk_columns_input {
  id: uuid!
}

"""
select columns of table "team_user"
"""
enum teamUser_select_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  role

  """column name"""
  teamId

  """column name"""
  updatedAt

  """column name"""
  userId
}

"""
input type for updating data in table "team_user"
"""
input teamUser_set_input {
  createdAt: timestamptz
  id: uuid
  role: String
  teamId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""
update columns of table "team_user"
"""
enum teamUser_update_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  role

  """column name"""
  teamId

  """column name"""
  updatedAt

  """column name"""
  userId
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "unit"
"""
type unit {
  """An array relationship"""
  bookings(
    """distinct select on columns"""
    distinct_on: [booking_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_order_by!]

    """filter the rows returned"""
    where: booking_bool_exp
  ): [booking!]!

  """An aggregate relationship"""
  bookings_aggregate(
    """distinct select on columns"""
    distinct_on: [booking_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_order_by!]

    """filter the rows returned"""
    where: booking_bool_exp
  ): booking_aggregate!

  """An object relationship"""
  connection: connection
  connectionId: uuid
  createdAt: timestamptz!

  """An object relationship"""
  entity: entity
  entityId: uuid
  id: uuid!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  name: String
  status: String

  """An array relationship"""
  tags(
    """distinct select on columns"""
    distinct_on: [tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tag_order_by!]

    """filter the rows returned"""
    where: tag_bool_exp
  ): [tag!]!

  """An aggregate relationship"""
  tags_aggregate(
    """distinct select on columns"""
    distinct_on: [tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tag_order_by!]

    """filter the rows returned"""
    where: tag_bool_exp
  ): tag_aggregate!

  """An object relationship"""
  team: team
  teamId: uuid
  uniqueRef: String
  updatedAt: timestamptz!
}

"""
aggregated selection of "unit"
"""
type unit_aggregate {
  aggregate: unit_aggregate_fields
  nodes: [unit!]!
}

"""
aggregate fields of "unit"
"""
type unit_aggregate_fields {
  count(columns: [unit_select_column!], distinct: Boolean): Int!
  max: unit_max_fields
  min: unit_min_fields
}

"""
order by aggregate values of table "unit"
"""
input unit_aggregate_order_by {
  count: order_by
  max: unit_max_order_by
  min: unit_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input unit_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "unit"
"""
input unit_arr_rel_insert_input {
  data: [unit_insert_input!]!

  """on conflict condition"""
  on_conflict: unit_on_conflict
}

"""
Boolean expression to filter rows from the table "unit". All fields are combined with a logical 'AND'.
"""
input unit_bool_exp {
  _and: [unit_bool_exp!]
  _not: unit_bool_exp
  _or: [unit_bool_exp!]
  bookings: booking_bool_exp
  connection: connection_bool_exp
  connectionId: uuid_comparison_exp
  createdAt: timestamptz_comparison_exp
  entity: entity_bool_exp
  entityId: uuid_comparison_exp
  id: uuid_comparison_exp
  metadata: jsonb_comparison_exp
  name: String_comparison_exp
  status: String_comparison_exp
  tags: tag_bool_exp
  team: team_bool_exp
  teamId: uuid_comparison_exp
  uniqueRef: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "unit"
"""
enum unit_constraint {
  """unique or primary key constraint"""
  unit_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input unit_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input unit_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input unit_delete_key_input {
  metadata: String
}

"""
input type for inserting data into table "unit"
"""
input unit_insert_input {
  bookings: booking_arr_rel_insert_input
  connection: connection_obj_rel_insert_input
  connectionId: uuid
  createdAt: timestamptz
  entity: entity_obj_rel_insert_input
  entityId: uuid
  id: uuid
  metadata: jsonb
  name: String
  status: String
  tags: tag_arr_rel_insert_input
  team: team_obj_rel_insert_input
  teamId: uuid
  uniqueRef: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type unit_max_fields {
  connectionId: uuid
  createdAt: timestamptz
  entityId: uuid
  id: uuid
  name: String
  status: String
  teamId: uuid
  uniqueRef: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "unit"
"""
input unit_max_order_by {
  connectionId: order_by
  createdAt: order_by
  entityId: order_by
  id: order_by
  name: order_by
  status: order_by
  teamId: order_by
  uniqueRef: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type unit_min_fields {
  connectionId: uuid
  createdAt: timestamptz
  entityId: uuid
  id: uuid
  name: String
  status: String
  teamId: uuid
  uniqueRef: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "unit"
"""
input unit_min_order_by {
  connectionId: order_by
  createdAt: order_by
  entityId: order_by
  id: order_by
  name: order_by
  status: order_by
  teamId: order_by
  uniqueRef: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "unit"
"""
type unit_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [unit!]!
}

"""
input type for inserting object relation for remote table "unit"
"""
input unit_obj_rel_insert_input {
  data: unit_insert_input!

  """on conflict condition"""
  on_conflict: unit_on_conflict
}

"""
on conflict condition type for table "unit"
"""
input unit_on_conflict {
  constraint: unit_constraint!
  update_columns: [unit_update_column!]! = []
  where: unit_bool_exp
}

"""Ordering options when selecting data from "unit"."""
input unit_order_by {
  bookings_aggregate: booking_aggregate_order_by
  connection: connection_order_by
  connectionId: order_by
  createdAt: order_by
  entity: entity_order_by
  entityId: order_by
  id: order_by
  metadata: order_by
  name: order_by
  status: order_by
  tags_aggregate: tag_aggregate_order_by
  team: team_order_by
  teamId: order_by
  uniqueRef: order_by
  updatedAt: order_by
}

"""primary key columns input for table: unit"""
input unit_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input unit_prepend_input {
  metadata: jsonb
}

"""
select columns of table "unit"
"""
enum unit_select_column {
  """column name"""
  connectionId

  """column name"""
  createdAt

  """column name"""
  entityId

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  name

  """column name"""
  status

  """column name"""
  teamId

  """column name"""
  uniqueRef

  """column name"""
  updatedAt
}

"""
input type for updating data in table "unit"
"""
input unit_set_input {
  connectionId: uuid
  createdAt: timestamptz
  entityId: uuid
  id: uuid
  metadata: jsonb
  name: String
  status: String
  teamId: uuid
  uniqueRef: String
  updatedAt: timestamptz
}

"""
update columns of table "unit"
"""
enum unit_update_column {
  """column name"""
  connectionId

  """column name"""
  createdAt

  """column name"""
  entityId

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  name

  """column name"""
  status

  """column name"""
  teamId

  """column name"""
  uniqueRef

  """column name"""
  updatedAt
}

"""
columns and relationships of "user"
"""
type user {
  createdAt: timestamptz
  email: String!
  id: uuid!
  isAdmin: Boolean!

  """An array relationship"""
  memberships(
    """distinct select on columns"""
    distinct_on: [teamUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamUser_order_by!]

    """filter the rows returned"""
    where: teamUser_bool_exp
  ): [teamUser!]!

  """An aggregate relationship"""
  memberships_aggregate(
    """distinct select on columns"""
    distinct_on: [teamUser_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teamUser_order_by!]

    """filter the rows returned"""
    where: teamUser_bool_exp
  ): teamUser_aggregate!
  name: String
  status: user_status_enum
  sub: String
  trialExpiryAt: timestamptz
}

"""
aggregated selection of "user"
"""
type user_aggregate {
  aggregate: user_aggregate_fields
  nodes: [user!]!
}

"""
aggregate fields of "user"
"""
type user_aggregate_fields {
  count(columns: [user_select_column!], distinct: Boolean): Int!
  max: user_max_fields
  min: user_min_fields
}

"""
Boolean expression to filter rows from the table "user". All fields are combined with a logical 'AND'.
"""
input user_bool_exp {
  _and: [user_bool_exp!]
  _not: user_bool_exp
  _or: [user_bool_exp!]
  createdAt: timestamptz_comparison_exp
  email: String_comparison_exp
  id: uuid_comparison_exp
  isAdmin: Boolean_comparison_exp
  memberships: teamUser_bool_exp
  name: String_comparison_exp
  status: user_status_enum_comparison_exp
  sub: String_comparison_exp
  trialExpiryAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "user"
"""
enum user_constraint {
  """unique or primary key constraint"""
  user_pkey
}

"""
input type for inserting data into table "user"
"""
input user_insert_input {
  createdAt: timestamptz
  email: String
  id: uuid
  isAdmin: Boolean
  memberships: teamUser_arr_rel_insert_input
  name: String
  status: user_status_enum
  sub: String
  trialExpiryAt: timestamptz
}

"""aggregate max on columns"""
type user_max_fields {
  createdAt: timestamptz
  email: String
  id: uuid
  name: String
  sub: String
  trialExpiryAt: timestamptz
}

"""aggregate min on columns"""
type user_min_fields {
  createdAt: timestamptz
  email: String
  id: uuid
  name: String
  sub: String
  trialExpiryAt: timestamptz
}

"""
response of any mutation on the table "user"
"""
type user_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user!]!
}

"""
input type for inserting object relation for remote table "user"
"""
input user_obj_rel_insert_input {
  data: user_insert_input!

  """on conflict condition"""
  on_conflict: user_on_conflict
}

"""
on conflict condition type for table "user"
"""
input user_on_conflict {
  constraint: user_constraint!
  update_columns: [user_update_column!]! = []
  where: user_bool_exp
}

"""Ordering options when selecting data from "user"."""
input user_order_by {
  createdAt: order_by
  email: order_by
  id: order_by
  isAdmin: order_by
  memberships_aggregate: teamUser_aggregate_order_by
  name: order_by
  status: order_by
  sub: order_by
  trialExpiryAt: order_by
}

"""primary key columns input for table: user"""
input user_pk_columns_input {
  id: uuid!
}

"""
select columns of table "user"
"""
enum user_select_column {
  """column name"""
  createdAt

  """column name"""
  email

  """column name"""
  id

  """column name"""
  isAdmin

  """column name"""
  name

  """column name"""
  status

  """column name"""
  sub

  """column name"""
  trialExpiryAt
}

"""
input type for updating data in table "user"
"""
input user_set_input {
  createdAt: timestamptz
  email: String
  id: uuid
  isAdmin: Boolean
  name: String
  status: user_status_enum
  sub: String
  trialExpiryAt: timestamptz
}

enum user_status_enum {
  active
  banned
  disabled
  trialExpired
}

"""
Boolean expression to compare columns of type "user_status_enum". All fields are combined with logical 'AND'.
"""
input user_status_enum_comparison_exp {
  _eq: user_status_enum
  _in: [user_status_enum!]
  _is_null: Boolean
  _neq: user_status_enum
  _nin: [user_status_enum!]
}

"""
update columns of table "user"
"""
enum user_update_column {
  """column name"""
  createdAt

  """column name"""
  email

  """column name"""
  id

  """column name"""
  isAdmin

  """column name"""
  name

  """column name"""
  status

  """column name"""
  sub

  """column name"""
  trialExpiryAt
}

"""
columns and relationships of "user_status"
"""
type userStatus {
  name: String!
}

"""
aggregated selection of "user_status"
"""
type userStatus_aggregate {
  aggregate: userStatus_aggregate_fields
  nodes: [userStatus!]!
}

"""
aggregate fields of "user_status"
"""
type userStatus_aggregate_fields {
  count(columns: [userStatus_select_column!], distinct: Boolean): Int!
  max: userStatus_max_fields
  min: userStatus_min_fields
}

"""
Boolean expression to filter rows from the table "user_status". All fields are combined with a logical 'AND'.
"""
input userStatus_bool_exp {
  _and: [userStatus_bool_exp!]
  _not: userStatus_bool_exp
  _or: [userStatus_bool_exp!]
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "user_status"
"""
enum userStatus_constraint {
  """unique or primary key constraint"""
  user_status_pkey
}

"""
input type for inserting data into table "user_status"
"""
input userStatus_insert_input {
  name: String
}

"""aggregate max on columns"""
type userStatus_max_fields {
  name: String
}

"""aggregate min on columns"""
type userStatus_min_fields {
  name: String
}

"""
response of any mutation on the table "user_status"
"""
type userStatus_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [userStatus!]!
}

"""
on conflict condition type for table "user_status"
"""
input userStatus_on_conflict {
  constraint: userStatus_constraint!
  update_columns: [userStatus_update_column!]! = []
  where: userStatus_bool_exp
}

"""Ordering options when selecting data from "user_status"."""
input userStatus_order_by {
  name: order_by
}

"""primary key columns input for table: userStatus"""
input userStatus_pk_columns_input {
  name: String!
}

"""
select columns of table "user_status"
"""
enum userStatus_select_column {
  """column name"""
  name
}

"""
input type for updating data in table "user_status"
"""
input userStatus_set_input {
  name: String
}

"""
update columns of table "user_status"
"""
enum userStatus_update_column {
  """column name"""
  name
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

"""
columns and relationships of "webhook"
"""
type webhook {
  createdAt: timestamptz!
  headers(
    """JSON select path"""
    path: String
  ): jsonb
  id: uuid!

  """An object relationship"""
  team: team!
  teamId: uuid!
  types(
    """JSON select path"""
    path: String
  ): jsonb!
  types2: _text
  url: String!
}

"""
aggregated selection of "webhook"
"""
type webhook_aggregate {
  aggregate: webhook_aggregate_fields
  nodes: [webhook!]!
}

"""
aggregate fields of "webhook"
"""
type webhook_aggregate_fields {
  count(columns: [webhook_select_column!], distinct: Boolean): Int!
  max: webhook_max_fields
  min: webhook_min_fields
}

"""
order by aggregate values of table "webhook"
"""
input webhook_aggregate_order_by {
  count: order_by
  max: webhook_max_order_by
  min: webhook_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input webhook_append_input {
  headers: jsonb
  types: jsonb
}

"""
input type for inserting array relation for remote table "webhook"
"""
input webhook_arr_rel_insert_input {
  data: [webhook_insert_input!]!

  """on conflict condition"""
  on_conflict: webhook_on_conflict
}

"""
Boolean expression to filter rows from the table "webhook". All fields are combined with a logical 'AND'.
"""
input webhook_bool_exp {
  _and: [webhook_bool_exp!]
  _not: webhook_bool_exp
  _or: [webhook_bool_exp!]
  createdAt: timestamptz_comparison_exp
  headers: jsonb_comparison_exp
  id: uuid_comparison_exp
  team: team_bool_exp
  teamId: uuid_comparison_exp
  types: jsonb_comparison_exp
  types2: _text_comparison_exp
  url: String_comparison_exp
}

"""
unique or primary key constraints on table "webhook"
"""
enum webhook_constraint {
  """unique or primary key constraint"""
  webhook_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input webhook_delete_at_path_input {
  headers: [String!]
  types: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input webhook_delete_elem_input {
  headers: Int
  types: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input webhook_delete_key_input {
  headers: String
  types: String
}

"""
input type for inserting data into table "webhook"
"""
input webhook_insert_input {
  createdAt: timestamptz
  headers: jsonb
  id: uuid
  team: team_obj_rel_insert_input
  teamId: uuid
  types: jsonb
  types2: _text
  url: String
}

"""aggregate max on columns"""
type webhook_max_fields {
  createdAt: timestamptz
  id: uuid
  teamId: uuid
  url: String
}

"""
order by max() on columns of table "webhook"
"""
input webhook_max_order_by {
  createdAt: order_by
  id: order_by
  teamId: order_by
  url: order_by
}

"""aggregate min on columns"""
type webhook_min_fields {
  createdAt: timestamptz
  id: uuid
  teamId: uuid
  url: String
}

"""
order by min() on columns of table "webhook"
"""
input webhook_min_order_by {
  createdAt: order_by
  id: order_by
  teamId: order_by
  url: order_by
}

"""
response of any mutation on the table "webhook"
"""
type webhook_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [webhook!]!
}

"""
on conflict condition type for table "webhook"
"""
input webhook_on_conflict {
  constraint: webhook_constraint!
  update_columns: [webhook_update_column!]! = []
  where: webhook_bool_exp
}

"""Ordering options when selecting data from "webhook"."""
input webhook_order_by {
  createdAt: order_by
  headers: order_by
  id: order_by
  team: team_order_by
  teamId: order_by
  types: order_by
  types2: order_by
  url: order_by
}

"""primary key columns input for table: webhook"""
input webhook_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input webhook_prepend_input {
  headers: jsonb
  types: jsonb
}

"""
select columns of table "webhook"
"""
enum webhook_select_column {
  """column name"""
  createdAt

  """column name"""
  headers

  """column name"""
  id

  """column name"""
  teamId

  """column name"""
  types

  """column name"""
  types2

  """column name"""
  url
}

"""
input type for updating data in table "webhook"
"""
input webhook_set_input {
  createdAt: timestamptz
  headers: jsonb
  id: uuid
  teamId: uuid
  types: jsonb
  types2: _text
  url: String
}

"""
update columns of table "webhook"
"""
enum webhook_update_column {
  """column name"""
  createdAt

  """column name"""
  headers

  """column name"""
  id

  """column name"""
  teamId

  """column name"""
  types

  """column name"""
  types2

  """column name"""
  url
}